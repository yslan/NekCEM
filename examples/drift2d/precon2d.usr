c-----------------------------------------------------------------------
c
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine userinc
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'


      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt, myhx, myhy, myhz, myex, myey, myez)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'DRIFT'  
      include 'NEKUSE'
      include 'POISSON'  
      
      real tt
      real myhx(lx1,ly1,lz1,lelt)
      real myhy(lx1,ly1,lz1,lelt)
      real myhz(lx1,ly1,lz1,lelt)
      real myex(lx1,ly1,lz1,lelt)
      real myey(lx1,ly1,lz1,lelt)
      real myez(lx1,ly1,lz1,lelt)

      do ie=1,nelt 
         if      (if_in_region(ie).eq. 1) then
             do i=1,nxyz
             j=(ie-1)*nxyz+i
             xx=xm1(i,1,1,ie)
             yy=ym1(i,1,1,ie)
             aa=sin(pi*xx)*sin(tt+1.0)
             cN(j)=aa**2
             cP(j)=2.0*cN(j)
             cE(j)=0.0
             enddo
         elseif (if_in_region(ie).eq.-1) then
             do i=1,nxyz
             j=(ie-1)*nxyz+i
             xx=xm1(i,1,1,ie)
             yy=ym1(i,1,1,ie)
             aa=sin(pi*xx)*sin(tt+1.0)
             cN(j)=aa**2
             cP(j)=2.0*cN(j)
             cE(j)=0.0
             enddo
         else
             if (nid.eq.0) write(6,*) 'if_in_region not defined in usr'
        endif
      enddo
 
      call cem_drift_poisson  !--> compute "potent"
      return
      end

c-----------------------------------------------------------------------
      subroutine usersol(tt, myshx, myshy, myshz, mysex, mysey, mysez)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'DRIFT'
      include 'NEKUSE'
      include 'GEOMBOUND'

      real tt
      real myshx(lx1,ly1,lz1,lelt)
      real myshy(lx1,ly1,lz1,lelt)
      real myshz(lx1,ly1,lz1,lelt)
      real mysex(lx1,ly1,lz1,lelt)
      real mysey(lx1,ly1,lz1,lelt)
      real mysez(lx1,ly1,lz1,lelt)

      real     omega, tmpH, tmpE
      real     xx, yy, zz, u    
      integer  i, j, k, e, ii, ind                 
     
      tt0=tt+1.0
      do ie=1,nelt 
         if      (if_in_region(ie).eq. 1) then
             do i=1,nxyz
             j=(ie-1)*nxyz+i
             xx=xm1(i,1,1,ie)
             yy=ym1(i,1,1,ie)
             aa=sin(pi*xx)*sin(tt0)
             scN(j)=aa**2
             scP(j)= 2.0*scN(j)
             scE(j)=0.0!scN(j)
             enddo
         elseif (if_in_region(ie).eq.-1) then
             do i=1,nxyz
             j=(ie-1)*nxyz+i
             xx=xm1(i,1,1,ie)
             yy=ym1(i,1,1,ie)
             aa=sin(pi*xx)*sin(tt0)
             scN(j)=aa**2
             scP(j)= 2.0*scN(j)
             scE(j)=0.0!scN(j)
             enddo
         else
             if (nid.eq.0) write(6,*) 'if_in_region not defined in usr'
        endif
      enddo 


      return
      end


c-----------------------------------------------------------------------
      subroutine usersrc(baseidx,srchx,srchy,srchz,srcex,srcey,srcez)
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'
      include 'RK5'
      include 'DRIFT'
      integer i,baseidx
      real    xx,yy,tt,aa,bb,cc,dd,ee,a1,a2
      real    srchx(1),srchy(1),srchz(1)
      real    srcex(1),srcey(1),srcez(1)
      tt=time+dt+1.d0
      do i=1,npts
         xx=xm1(i,1,1,1)
         yy=ym1(i,1,1,1)
         aa=dsin(pi*xx)**2
         bb=dsin(2.d0*tt)*aa   !du/dt
         aa=aa*dsin(tt)**2   ! u
         cc=-pi**2*dsin(tt)**2*dcos(2.d0*pi*xx)
         cc=2.0*cc
         a1=pi*dsin(2.d0*pi*xx)*dsin(tt)**2
         a2=0.d0
         dd=(a1**2+a2**2)!\phi_xu_x+\phi_yu_y
         ee=-aa*cc !\mu_n\delta \phi  u
         srchx(i)=bb+cc+dd+ee
         srchy(i)=(bb+cc-dd-ee)
         srchy(i)=2.d0*srchy(i)
         srchz(i)=0.0!(bb+cc+dd)
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,iel)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'DRIFT' 

      integer  n, ix, iy, iz, ieg
      real     one, xcc, ycc, zcc, x1, y1, z1
      real     lambda, fc, wc                     

      permea = permea_0             
      permit = permit_0                
      mu_n   = permea_0             
      mu_p   = permit_0                

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
C
      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
C

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux=0.0
      uy=0.0
      uz=0.0
      temp=0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      return
      end

c-----------------------------------------------------------------------
      subroutine usrdat2

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'GEOMBOUND'
      real     rscale
      n = nx1*ny1*nz1*nelv


      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)
      zmin = glmin(zm1,n)
      zmax = glmax(zm1,n)

c      rscale = 10.0**(-9)             ! nanoscale                                                  
      rscale =0.02      !FIXME FOR TESTING     
      sx = 100.0*rscale/(xmax-xmin)
      sy = 100.0*rscale/(ymax-ymin)       
      if (nid.eq.0) write(6,*) 'sx/sy',sx,sy,rscale
  
      do i=1,n
         xm1(i,1,1,1) = sx*(xm1(i,1,1,1)-xmin)-1.0               
         ym1(i,1,1,1) = sy*(ym1(i,1,1,1)-ymin)-1.0                        
      enddo

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)

      if (nid.eq.0) write(6,*) 'xmin/xmax', xmin,xmax
      if (nid.eq.0) write(6,*) 'ymin/ymax', xmin,xmax
      mx = nx1/2
      my = ny1/2
      mz = 1
      do ie=1,nelt

         xxmax = vlmax(xm1(1,1,1,ie),nxyz)
         xxmin = vlmin(xm1(1,1,1,ie),nxyz)
         yymax = vlmax(ym1(1,1,1,ie),nxyz)
         yymin = vlmin(ym1(1,1,1,ie),nxyz)

         xxmid = xm1(mx,my,mz,ie)
         yymid = ym1(mx,my,mz,ie)

c         if (yymid.gt.50*rscale) then
         if (yymid.gt. 0) then
             if_in_region(ie) =  1
             write(6,*) 're: 1',ie    
         else
             if_in_region(ie) = -1
             write(6,*) 're: 2',ie    
         endif

      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine userft           
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'


      return
      end

c-----------------------------------------------------------------------
      subroutine userchk
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'DRIFT' 
      include 'POISSON'

      common /ccpu/ cpu_t,cpu_dtime,cpu_chk
      real    dummy(lpts4)

c ... compute errors


      if (istep.le.10.or.mod(istep,iocomm).eq.0) then

        ntott = nx1*ny1*nz1*nelt
        npts3 = nx1*ny1*nz1*nelt*3
        nsrf  = nx1*nz1*nelt*6

        if (ifsol) then
          call usersol(time,scn,scp,sce,scn,scp,sce)      
        else
          call rzero(scn, npts) 
          call rzero(scp, npts) 
          call rzero(sce, npts) 
        endif

        call sub3(ErrN,scN,cN,npts) 
        call sub3(ErrP,scP,cP,npts) 
c       call sub3(ErrE,scn,potent,npts) ! temporary: computed in cem_drift_op_bdf 

        HXmr = glamax(ErrN,npts)  
        HYmr = glamax(ErrP,npts) 
        HZmr = glamax(ErrE,npts) 
        EXmr = glamax(ErrN,npts) 
        EYmr = glamax(ErrP,npts)  
        EZmr = glamax(ErrE,npts) 
   
        call col2(errn,mult,npts) 
        call col2(errp,mult,npts) 
        call col2(erre,mult,npts)
 
        HXer = glsc3(ErrN,bm1,ErrN,NTOTT)/ volvm1
        HYer = glsc3(ErrP,bm1,ErrP,NTOTT)/ volvm1
        HZer = glsc3(ErrE,bm1,ErrE,NTOTT)/ volvm1
        EXer = glsc3(ErrN,bm1,ErrN,NTOTT)/ volvm1
        EYer = glsc3(ErrP,bm1,ErrP,NTOTT)/ volvm1
        EZer = glsc3(ErrE,bm1,ErrE,NTOTT)/ volvm1
        
        if (hxer.gt.0) hxer = sqrt(hxer)
        if (hyer.gt.0) hyer = sqrt(hyer)
        if (hzer.gt.0) hzer = sqrt(hzer)
        if (exer.gt.0) exer = sqrt(exer)
        if (eyer.gt.0) eyer = sqrt(eyer)
        if (ezer.gt.0) ezer = sqrt(ezer)

c----- temporaty
        if (istep.eq. 1) then
        if (nid.eq.0) write(10,*) 'Linf norm (cn,cp,phi)',nstep, dt
        if (nid.eq.0) write(11,*) 'L2   norm (cn,cp,phi)',nstep, dt
        if (nid.eq.0) write(10,*) Hxmr,Hymr,Hzmr
        if (nid.eq.0) write(11,*) Hxer,hyer,hzer
        else
        if (nid.eq.0) write(10,*) Hxmr,Hymr,Hzmr
        if (nid.eq.0) write(11,*) Hxer,hyer,hzer
        endif
c ... print statement

        snel = nelt + .5
        snel = sqrt(snel)
        nels = snel
        nnn  = nx1-1
        npt1 = nnn*nels
        npts = nx1*ny1*nz1*nelt ! npts = npt1**ndim

        if (istep.eq.0)       cpu_p_t= 0
        if (istep.gt.0)       cpu_p_t= cpu_t/(npts*istep)
        if (istep.eq.nsteps)  cpu_p_t= glsum(cpu_p_t,1)/np

        if (nid.eq.0) then

         if (istep.eq.1) write(6,90)
         write(6,91) ISTEP,nelt,nels,nnn,npt1,npts
     $         ,time,dt,HXer,HYer,HZer,EXer,EYer,EZer,cpu_t,cpu_p_t
         write(6,95) ISTEP,nelt,nels,nnn,npt1,npts
     $         ,time,dt,HXmr,HYmr,HZmr,EXmr,EYmr,EZmr,cpu_t,cpu_p_t


 90      format(/,'    istep   nelt  nels  N  npt1    npts   time
     $  dt     cNerr     cPerr     cEerr     cNerr     cPerr     cEerr
     $  cpu_t   cpu_t_pts')
 91      format(/,i10,3i5,i5,i9,1p9e10.3,e9.2,' CPU: L2  '  )
 95      format(  i10,3i5,i5,i9,1p9e10.3,e9.2,' CPU: Linf'  )


        endif ! nid=0

      endif

      return
      end
c-----------------------------------------------------------------------

