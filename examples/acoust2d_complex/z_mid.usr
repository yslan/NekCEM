c-----------------------------------------------------------------------
c
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine userinc
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'


      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt, myhx, myhy, myhz, myex, myey, myez)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'ZCOUSTIC'

      real tt,energy_err,flag(6)
      real lambda,reflectivity,kw3_r,kw3_i,kw4_r,kw4_i
      real myhx(lx1,ly1,lz1,lelt)
      real myhy(lx1,ly1,lz1,lelt)
      real myhz(lx1,ly1,lz1,lelt)
      real myex(lx1,ly1,lz1,lelt)
      real myey(lx1,ly1,lz1,lelt)
      real myez(lx1,ly1,lz1,lelt)

      complex*16 ci, z_d1,z_d2
      complex*16 z_tmpk1, z_tmpk2
      complex*16 z_tmp  , z_tmp2
      complex*16 z_tmp_kwave1
      complex*16 z_tmp_kwave2
      complex*16 tmp_kw (15)
      real       tmp_lam(15)
      integer e
      
      if (nid.eq.0) open(unit=111,file='z_data.txt')
      if (nid.eq.0) write(6,*) 'reading data file z_flat_data.txt'
c..   user defined wavenumber for different DTN directions
      ci  =(0.0,1.0)

      do k=1,1  

      z_kw(1)= 0   ! negative x-direction DTN  
      z_kw(2)= 0   ! positive x-direction DTN

      if (nid.eq.0) read(111,*) kw3_r,kw3_i,kw4_r,kw4_i
      if (nid.eq.0) write(6,*) 'xxx',k,kw3_r,kw3_i
      if (nid.eq.0) write(6,*) 'xxx',k,kw4_r,kw4_i

      z_kw(3)=kw3_r+kw3_i*ci
      z_kw(4)=kw4_r+kw4_i*ci
      z_kw(3)= 18.5159+22.069*ci          ! \lambda=1023 
      z_kw(4)= 6.1419                     ! \lambda=1023 
      
      z_kw(5)= 0   ! negative z-direction DTN
      z_kw(6)= 0   ! positive z-direction DTN
 
      call rzero(flag,6)

      flag(3)= 0 ! not include the bottom part
      flag(4)= 1 !incident from top

c..   only for the energy test
      kw(3)= real(z_kw(3))
      kw(4)= real(z_kw(4))
c...  assign temporary values of wavenumber kw
      alp0=0.0
      z_tmpk1=cdsqrt(z_kw(3)**2-alp0**2)
      z_tmpk2=cdsqrt(z_kw(4)**2-alp0**2)

C...  define parameters for two medium layers   
      amid=0.0
      z_d1=2.0*z_tmpk2/(z_tmpk1+z_tmpk2)*exp(-ci*(z_tmpk2-z_tmpk1)*amid)
      z_d2=(z_tmpk2-z_tmpk1)/(z_tmpk1+z_tmpk2)*exp(-ci*2.0*z_tmpk2*amid)

C...  define parameters for multilayer    
      do e=1,nelt
         if     (if_in_region(e).eq.1) then  ! multilayer 
               z_alpha0(e)= alp0
               z_beta0 (e)= z_tmpk1
         elseif (if_in_region(e).eq.2) then  ! multilayer
               z_alpha0(e)= alp0
               z_beta0 (e)= z_tmpk2
         endif
      enddo
      
C...  box mesh with periodic boundary
      n = npts
      n2= npts*2

      do e= 1,nelt
          if    (if_in_region(e).eq.1) then !bottom layer
             z_tmp_kwave1 = z_kw(3)
             z_tmp_kwave2 = z_beta0(e)**2
             do i= 1,nxyz 
                j= i+(e-1)*nxyz
                xx= xm1(j,1,1,1)
                yy= ym1(j,1,1,1)
                zz= zm1(j,1,1,1)
                z_kwave1 (  j) = z_tmp_kwave1
                z_kwave2 (  j) = z_tmp_kwave2
                z_rhs_inc(  j) = 0.0 ! real: incident wave
                z_spotent(  j) = z_d1*exp(ci
     $                          *(z_alpha0(e)*xx-z_beta0(e)*yy))
             enddo
         elseif (if_in_region(e).eq.2) then ! top layer
             z_tmp_kwave1 = z_kw(4)
             z_tmp_kwave2 = z_beta0(e)**2
             do i= 1,nxyz 
                j= i+(e-1)*nxyz
                xx= xm1(j,1,1,1)
                yy= ym1(j,1,1,1)
                zz= zm1(j,1,1,1)
                z_kwave1 (  j) = z_tmp_kwave1
                z_kwave2 (  j) = z_tmp_kwave2
                z_rhs_inc(  j) = exp(ci*(z_alpha0(e)*xx-z_beta0(e)*yy)) ! real: incident wave
                z_spotent(  j) = z_rhs_inc(j)
     $                  + z_d2*exp(ci*(z_alpha0(e)*xx+z_beta0(e)*yy))
             enddo
         endif
      enddo
 10   format(i5,4f13.5)

      call z2r_copy(rhs_inc(1),rhs_inc(n+1),z_rhs_inc,n)
      call cem_dtn_quasi_sol(rhs_inc(1),alp0,2)
      call r2z_copy(z_rhs_inc,rhs_inc(1),rhs_inc(n+1),n)
      call maxwell_grad(dxinc(  1),dyinc(  1),dzinc(  1),rhs_inc(  1))
      call maxwell_grad(dxinc(n+1),dyinc(n+1),dzinc(n+1),rhs_inc(n+1))
      call copy (rhs_nmn,dyinc,n2) ! assing neumman part boundary condition
      call r2z_copy(z_rhs_nmn,rhs_nmn(1),rhs_nmn(n+1),n)

      call z_hmhDtN  ! return potent --> total field         

      call cem_dtn_quasi_sol(potent(1),alp0,1)
      call cem_dtn_quasi_sol(rhs_inc(1),alp0,1)
  
      call r2z_copy(z_potent,potent(1),potent(n+1),n)

      call sub3(scaten(1,2),potent(  1),rhs_inc(  1),n) ! scattered field
      call sub3(scathn(1,2),potent(n+1),rhs_inc(n+1),n)

      call cem_acoustic_test2(energy_err,flag,real(z_beta0(nelt)),2*pi)

      t_lam = tmp_lam(k)        
      tr_kw = real(z_kw(3))     
      ti_kw = imag(z_kw(3))     

      if (nid.eq.0) write(6,70) t_lam,tr_kw,ti_kw,energy_err
      
      call copy(en(1,1),potent (  1),n)   ! numeric total field real
      call copy(hn(1,1),potent (n+1),n)   ! numeric total field imag
      call copy(en(1,2),scaten (1,2),n)   ! numeric scattered real
      call copy(hn(1,2),scathn (1,2),n)   ! numeric scattered imag
      call copy(en(1,3),rhs_inc(  1),n)   ! numeric incident real
      call copy(hn(1,3),rhs_inc(n+1),n)   ! numeric incident imag
      
      
      call z2r_copy(spotent(1),spotent(n+1),z_spotent,n)
      
c      call copy(en(1,3),spotent(  1),n)   ! exact total field real
c      call copy(hn(1,3),spotent(n+1),n)   ! exact total field imag
      call sub3(epotent(  1),potent(  1),spotent(  1),n)
      call sub3(epotent(n+1),potent(n+1),spotent(n+1),n)

      smax1  = glmax (scaten (1,2),n)
      smax2  = glmax (scathn (1,2),n)
      smin1  = glmin (scaten (1,2),n)
      smin2  = glmin (scathn (1,2),n)

      pmax1  = glmax (potent (  1),n)
      pmax2  = glmax (potent (n+1),n)
      pmin1  = glmin (potent (  1),n)
      pmin2  = glmin (potent (n+1),n)

      errmax1= glamax(epotent(  1),n)
      errmax2= glamax(epotent(n+1),n)

      if (nid.eq.0) write(6,20)  smax1  ,smin1
      if (nid.eq.0) write(6,30)  smax2  ,smin2
      if (nid.eq.0) write(6,40)  pmax1  ,pmin1
      if (nid.eq.0) write(6,50)  pmax2  ,pmin2
      if (nid.eq.0) write(6,60)  errmax1,errmax2,nx1-1,nelt,nelgt,np

 20   format(' val_sct    :: real max/min=',2e25.15)
 30   format(' val_sct    :: imag max/min=',2e25.15)
 40   format(' val_tot    :: real max/min=',2e25.15)
 50   format(' val_tot    :: imag max/min=',2e25.15)
 60   format(' val_err_tot::    real/imag:',2e25.15,4i8)
 70   format(' energy_err ::',e20.10,1p3e25.15)

      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usersol(tt, myshx, myshy, myshz, mysex, mysey, mysez)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      real tt
      real myshx(lx1,ly1,lz1,lelt)
      real myshy(lx1,ly1,lz1,lelt)
      real myshz(lx1,ly1,lz1,lelt)
      real mysex(lx1,ly1,lz1,lelt)
      real mysey(lx1,ly1,lz1,lelt)
      real mysez(lx1,ly1,lz1,lelt)

c     npts=nx1*ny1*nz1*nelt

      do i = 1,npts
         xx= xm1(i,1,1,1)
         yy= ym1(i,1,1,1)
         zz= zm1(i,1,1,1)
         myshx(i,1,1,1)  =-pi*sin(pi*xx)*cos(pi*yy)
         myshy(i,1,1,1)  =-pi*cos(pi*xx)*sin(pi*yy)
         myshz(i,1,1,1)  = 0
         mysex(i,1,1,1)  =-pi*sin(pi*xx)*cos(pi*yy)
         mysey(i,1,1,1)  =-pi*cos(pi*xx)*sin(pi*yy)
         mysez(i,1,1,1)  = 0
      enddo


      return
      end
c-----------------------------------------------------------------------
      subroutine usersrc(baseidx,srchx,srchy,srchz,srcex,srcey,srcez)

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'


      return
      end
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,iel)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy, iz, ieg
      real      one, xcc, ycc, zcc, x1, y1, z1
      real     lambda, fc, wc                     

      permea = permea_0             
      permit = permit_0                

      ! if_in_region(iel) define in usrdat2

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
C
      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
C

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux=0.0
      uy=0.0
      uz=0.0
      temp=0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      return
      end

c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      integer  e

      n    = nx1*ny1*nz1*nelv

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)


      write(6,*) 'xmin/xmax',xmin,xmax
      write(6,*) 'ymin/ymax',ymin,ymax

      target_width  = 600.
      target_height = 450.
      target_angle  = 55.*(pi/180.)   ! Between 50 and 80 seems ok

c     target_angle  =  atan(target_height/x0)
      target_x0     = -target_height/tan(target_angle)
      target_x1     =  target_x0 + target_width

      x0 = -1.
      x1 =  1.
      call rescale_x(xm1,x0,x1)
      do i=1,n
         x=xm1(i,1,1,1)
         if (x.lt.0) xm1(i,1,1,1) = -x*target_x0
         if (x.gt.0) xm1(i,1,1,1) =  x*target_x1
      enddo

      call cmult(ym1,target_height,n)

      mx = nx1/2
      my = ny1/2
      mz = 1

      do e=1,nelt
         xxmid = xm1(mx,my,mz,e)
         yymid = ym1(mx,my,mz,e)

         if_in_region(e)=2    

         if (xxmid.lt.0) then  ! point1=(target_x0,0), point2=(0,target_height)
             slope= -target_height/target_x0
             target_y= slope *(xxmid - target_x0) 
             if (yymid.lt.target_y) then
                 if_in_region(e)=1      
                 write(6,*) 'tungsten: x<0',e
             endif
         else                 ! point1= (0,target_height), point1=(target_x1,0)
             slope= -target_height/target_x1
             target_y= slope *(xxmid - target_x1) 
             if (yymid.lt.target_y) then
                 if_in_region(e)=1      
                 write(6,*) 'tungsten: x>0',e
             endif
         endif
      enddo

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)

      do i=1,n
         xm1(i,1,1,1) = xm1(i,1,1,1)+abs(xmin)
         ym1(i,1,1,1) = ym1(i,1,1,1)+abs(ymin)
      enddo

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)
      write(6,*) '2 pi scale: xmin,xmax,ymin,ymax:',xmin,xmax,ymin,ymax

      xscale= 2.0*pi/600.0
      yscale= 2.0*pi/600.0
      do i=1,n
         xm1(i,1,1,1) = xscale*xm1(i,1,1,1)
         ym1(i,1,1,1) = yscale*ym1(i,1,1,1)
      enddo

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)
      write(6,*) 'final xmin,xmax,ymin,ymax:',xmin,xmax,ymin,ymax

      return
      end
c-----------------------------------------------------------------------
      subroutine userft           
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'


      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'ACOUSTIC'
      include 'mpif.h'

      common /rparts/ pts_in(ldim,lpart),val_in(2,lpart)
      common /vparts/ val_out (2,lpart)
     $              , val_out1(2,lpart)
     $              , val_out2(2,lpart)
      common /iparts/ npart,partpt(lpart)
      common /ndata/  nxx,nyy,nzz,npoints
      integer         nxx,nyy,nzz,npoints
      integer npart
      integer wcnt
      save wcn0,wcnt
      data wcn0,wcnt  /2*0/
 
      common /ccpu/ cpu_t,cpu_dtime,cpu_chk

c ... compute errors

      if (istep.le.10.or.mod(istep,iocomm).eq.0) then

        ntott = nx1*ny1*nz1*nelt
        npts3 = nx1*ny1*nz1*nelt*3
        nsrf  = nx1*nz1*nelt*6

        if (ifsol) then
          call usersol(time,sHN(1,1),sHN(1,2),sHN(1,3),
     $                      sEN(1,1),sEN(1,2),sEN(1,3))
        else
          call rzero(sHN, npts3) 
          call rzero(sEN, npts3) 
        endif

        call sub3(ErrHN(1,1),SHN(1,1),HN(1,1),NTOTT)
        call sub3(ErrHN(1,2),SHN(1,2),HN(1,2),NTOTT)
        call sub3(ErrHN(1,3),SHN(1,3),HN(1,3),NTOTT)
        call sub3(ErrEN(1,1),SEN(1,1),EN(1,1),NTOTT)
        call sub3(ErrEN(1,2),SEN(1,2),EN(1,2),NTOTT)
        call sub3(ErrEN(1,3),SEN(1,3),EN(1,3),NTOTT)

        HXmr = glamax(ErrHN(1,1),NTOTT)
        HYmr = glamax(ErrHN(1,2),NTOTT)
        HZmr = glamax(ErrHN(1,3),NTOTT)
        EXmr = glamax(ErrEN(1,1),NTOTT)
        EYmr = glamax(ErrEN(1,2),NTOTT)
        EZmr = glamax(ErrEN(1,3),NTOTT)
 
        HXer = glsc3(ErrHN(1,1),bm1,ErrHN(1,1),NTOTT)/ volvm1
        HYer = glsc3(ErrHN(1,2),bm1,ErrHN(1,2),NTOTT)/ volvm1
        HZer = glsc3(ErrHN(1,3),bm1,ErrHN(1,3),NTOTT)/ volvm1
        EXer = glsc3(ErrEN(1,1),bm1,ErrEN(1,1),NTOTT)/ volvm1
        EYer = glsc3(ErrEN(1,2),bm1,ErrEN(1,2),NTOTT)/ volvm1
        EZer = glsc3(ErrEN(1,3),bm1,ErrEN(1,3),NTOTT)/ volvm1

        if (hxer.gt.0) hxer = sqrt(hxer)
        if (hyer.gt.0) hyer = sqrt(hyer)
        if (hzer.gt.0) hzer = sqrt(hzer)
        if (exer.gt.0) exer = sqrt(exer)
        if (eyer.gt.0) eyer = sqrt(eyer)
        if (ezer.gt.0) ezer = sqrt(ezer)

c ... print statement

        snel = nelt + .5
        snel = sqrt(snel)
        nels = snel
        nnn  = nx1-1
        npt1 = nnn*nels
        npts = nx1*ny1*nz1*nelt ! npts = npt1**ndim

        if (istep.eq.0)       cpu_p_t= 0
        if (istep.gt.0)       cpu_p_t= cpu_t/(npts*istep)
        if (istep.eq.nsteps)  cpu_p_t= glsum(cpu_p_t,1)/np

        if (nid.eq.0) then

         if (istep.eq.1) write(6,90)
         write(6,91) ISTEP,nelt,nels,nnn,npt1,npts
     $         ,time,dt,HXer,HYer,HZer,EXer,EYer,EZer,cpu_t,cpu_p_t
         write(6,95) ISTEP,nelt,nels,nnn,npt1,npts
     $         ,time,dt,HXmr,HYmr,HZmr,EXmr,EYmr,EZmr,cpu_t,cpu_p_t


 90      format(/,'    istep   nelt  nels  N  npt1    npts   time
     $  dt     HXerr     HYerr     HZerr     EXerr     EYerr     EZerr
     $  cpu_t   cpu_t_pts')
 91      format(/,i10,3i5,i5,i9,1p9e10.3,e9.2,' CPU: L2  '  )
 95      format(  i10,3i5,i5,i9,1p9e10.3,e9.2,' CPU: Linf'  )


        endif ! nid=0

      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine interp_v(uvw,xyz,n,mode)
c
c     evaluate velocity for list of points xyz
c
c     Note:  -- modify
c     intpts to get rid off " WARNING: point on boundary or ..."

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'ACOUSTIC'
      integer mode
c...  real    uvw(ldim,n),xyz(ldim,n)
      real    uvw(2,n),xyz(ldim,n)
      logical ifjac,ifpts
      integer nmax,nfldmax
c...  parameter(nmax=lpart,nfldmax=ldim)
      parameter(nmax=lpart,nfldmax=2) 
      common /rv_intp/ pts(ldim*nmax)
      common /iv_intp/ ihandle
c...  common /outtmp/ wrk(lx1*ly1*lz1*lelt,ldim)
      common /outtmp/ wrk(lx1*ly1*lz1*lelt,2)

      common /ndata/  nxx,nyy,nzz,npoints
      integer         nxx,nyy,nzz,npoints

      integer icalld,e
      save    icalld
      data    icalld /0/

      if (n.gt.nmax) call exitti ('ABORT: interp_v() n > nmax!$',n)
      
      if (nelgt.ne.nelgv) call exitti
     $   ('ABORT: interp_v() nelgt.ne.nelgv not yet supported!$',nelgv)

      do i=1,n                          ! ? not moving -> save?
         pts(i)     = xyz(1,i)
         pts(i + n) = xyz(2,i)
         if (if3d)  pts(i + n*2) = xyz(3,i)
      enddo

      if (icalld.eq.0) then             ! interpolation setu !? intpts_done(ih_intp_v)?
          icalld = 1
          tolin  = 1.e-8
          call intpts_setup(tolin,ihandle)
      endif

c...  nflds  = ndim ! number of fields to interpolate
      nflds  = 2    ! number of fields to interpolate

      !pack working array
      !call opcopy(wrk(1,1),wrk(1,2),wrk(1,3),shn(3,1),sen(1,1),sen(2,1))
      

      if     (mode.eq.0) then
        do i=1,npts
         wrk(i,1)= potent(     i)-rhs_inc(     i)  !scat
         wrk(i,2)= potent(npts+i)-rhs_inc(npts+i)  !scat
        enddo
      elseif (mode.eq.1) then
        do i=1,npts
         wrk(i,1)= potent(     i)                  !tot
         wrk(i,2)= potent(npts+i)                  !tot
        enddo
      elseif (mode.eq.2) then
        do i=1,npts
         wrk(i,1)= rhs_inc(     i)                !inc
         wrk(i,2)= rhs_inc(npts+i)                !inc
        enddo
      endif

 20   format('nekcem fields::',i5,4e20.10)


      ! interpolate
      ifjac  = .true.           ! output transpose (of Jacobian)
      ifpts  = .true.           ! find points
      call intpts(wrk,nflds,pts,n,uvw,ifjac,ifpts,ihandle) ! copy array instead?

      return
      end
c-----------------------------------------------------------------------
      subroutine particle_init (x,npartl,lglprt,wcnt,nwire)
c
c     This is an example of initializing particles
c
      include 'SIZE'
      include 'INPUT'
      include 'GEOM'
      include 'PARALLEL'

      real     x(ldim,lpart)
      integer  npart,npartl,lglprt(lpart),wcnt,nprow
     $        ,pstt,pend,istt,iend,lstt,lend

      integer icalld
      save    icalld
      data    icalld /0/

      ntot_particle = 6400      ! Total number of admissable particles
      npartl = ntot_particle/np  

      if (npartl.gt.lpart.and.nid.eq.0)
     $     write(6,*) "WARNING: Resetting npartl to lpart",npartl,lpart

      npartl = min(npartl,lpart)
      npart  = npartl * np


C     Create particle pointer & zero out positions
      pstt = nid*npartl    + 1  ! particle_start_index on nid
      pend = pstt + npartl - 1  ! particle_end_index on nid

      if (icalld.eq.0) then
         if (nid.eq.0) write(6,*) npart," total particles"
         kpart = 0
         do i=pstt,pend
            kpart         = kpart + 1
            lglprt(kpart) = i  ! local to global index for particle
            write(6,*) 'lglprt',i,kpart,lglprt(kpart)
         enddo
      endif

C     Set wire parameters     ---  istt & iend are global ids

      nprow  = npart/nwire        ! number of particles per wire trigger
      ymin   = -1.0 !-.25               ! start & end of wire
      ymax   =  1.0 ! 0.25
      yscale = (ymax-ymin) / (nprow-1)
      istt   = (wcnt-1)*nprow + 1
      iend   = istt   + nprow - 1

C     Assign new wire to proc(s)
      lstt = istt - pstt + 1    ! set position in local array
      lend = iend - pstt + 1
      lend = min(npartl,lend)   ! check bounds
      if (lstt.lt.1)    lstt = 1
      if (lend.lt.1)    lend = 0
      if (istt.ge.pstt) ipos = 0
      if (istt.lt.pstt) ipos = mod(pstt,istt)

      do i=lstt,lend
         ipos   = ipos + 1
         x(1,i) = -1.
         x(2,i) = ymin + yscale*(ipos-1)
         x(3,i) =  0.125
      enddo

      icalld = icalld + 1

      return
      end
c-----------------------------------------------------------------------
      subroutine particle_out (x,xs,npart,partpt)
      include 'SIZE'
      include 'mpif.h'
      common /nekmpi/ mid,np,nekcomm,nekgroup,nekreal
      integer status(mpi_status_size)

      real x(ldim,lpart),xs(ldim,4,lpart),x_tmp(ldim,lpart)
      integer partpt(lpart),partpt_tmp(lpart),sender

      character*128 fname

      integer icalld
      save    icalld
      data    icalld  /0/

      if (nid.eq.0) then
        write(fname,1) icalld
 1      format('part.',i5.5)
        open(unit=72,file=fname)

        write(72,2) ((x(k,i),k=1,ndim),partpt(i),i=1,npart)
 2      format(1p3e15.7,i9)     ! # after p should be ndim

        do ip=1,np-1
           call mpi_recv (x_tmp,ndim*npart,nekreal
     $                   ,mpi_any_source,20,nekcomm,status,ierr)
           sender = status(mpi_source)
           call mpi_recv (partpt_tmp,npart,mpi_integer
     $                   ,sender        ,20,nekcomm,status,ierr)

           write(72,3) ((x_tmp(k,i),k=1,ndim),partpt_tmp(i),i=1,npart)
 3         format(1p3e15.7,i9)  ! # after p should be ndim
        enddo

        close(72)
      else
        call mpi_send (x,ndim*npart,nekreal
     $                ,0,20,nekcomm,ierr)
        call mpi_send (partpt,npart,mpi_integer
     $                ,0,20,nekcomm,ierr)
      endif

      icalld = icalld + 1

      return
      end
c-----------------------------------------------------------------------
      subroutine quick_read_ascii2       
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'ACOUSTIC'

      common /rparts/ pts_in(ldim,lpart),val_in(2,lpart)
      common /iparts/ npart,partpt(lpart)
      common /scrns4/ wpts(3,lpart),wpts2(3,lpart),
     $                wflds(2,lpart),wflds2(2,lpart)
      common /ndata/  nxx,nyy,nzz,npoints
      integer         nxx,nyy,nzz,npoints
      real            wpts, wpts2

      nxx= 80   !UPDATE nxx specify: can be any integer!!! lpart > nxx*nyy      
      nyy= 81          
      nzz=  1          

      npoints = nxx*nyy*nzz
      npoints2= 2*npoints
      npoints3= 3*npoints

c     if (nid.eq.0) read (106,*)  nxx,nyy,nnz,npoints                             
c     if (nid.eq.0) write(  6,*) 'nxx,nyy,nnz,npoints=',nxx,nyy,nzz,npoints

      if (nid.eq.0) then
         if (lpart.lt.npoints) then
             write(6,*) 'set lpart larger than npoints = ',npoints
             call exitt
         endif
      endif

      xmax=glmax(xm1,npts)
      xmin=glmin(xm1,npts)
      ymax=glmax(ym1,npts)
      ymin=glmin(ym1,npts)

      xfix = (xmax+xmin)/2.0
      yfix = (ymax+ymin)/2.0

      do i=1,nxx
      do j=1,nyy
         k=j+nyy*(i-1)
         wpts2(1,k)=xmin+(xmax-xmin)/nxx*(i-1)
         wpts2(2,k)=ymin+(ymax-ymin)/nyy*(j-1)
      enddo
      enddo

c...  assign temporary values of wavenumber kw
      alp0=alpha0(1)
      tmpk1=sqrt(kw(3)**2-alp0**2)
      tmpk2=sqrt(kw(4)**2-alp0**2)

C...  define parameters for two medium layers
      amid=0.0
      dr1= 2.0*tmpk2/(tmpk1+tmpk2)*cos((tmpk2-tmpk1)*amid)
      di1=-2.0*tmpk2/(tmpk1+tmpk2)*sin((tmpk2-tmpk1)*amid)
      dr2= (tmpk2-tmpk1)/(tmpk1+tmpk2)*cos(2.0*tmpk2*amid)
      di2=-(tmpk2-tmpk1)/(tmpk1+tmpk2)*sin(2.0*tmpk2*amid)
      
      tol = 1.0e-10 
      do i= 1,npoints
         xx= wpts2(1,i)
         yy= wpts2(2,i)
         
         if     ((yy-yfix).le.tol) then ! if (yymid.lt.yfix) then
              alpha =alp0
              beta  =sqrt(kw(3)**2-alpha**2)
              cos_tmp      = cos(alpha*xx-beta*yy)
              sin_tmp      = sin(alpha*xx-beta*yy)
              wflds2(1,i) = dr1*cos_tmp - di1*sin_tmp  !total
              wflds2(2,i) = dr1*sin_tmp + di1*cos_tmp  !total
         else    
              alpha= alp0
              beta = sqrt(kw(4)**2-alpha**2)
              cos_tmp      = cos(alpha*xx+beta*yy)
              sin_tmp      = sin(alpha*xx+beta*yy)
              cos_tmp1     = cos(alpha*xx-beta*yy)
              sin_tmp1     = sin(alpha*xx-beta*yy)
              wflds2(1,i) = dr2*cos_tmp - di2*sin_tmp !scat+inc
     $                     +cos_tmp1
              wflds2(2,i) = dr2*sin_tmp + di2*cos_tmp !scat+inc
     $                     +sin_tmp1
         endif
      enddo

      do i=1,npoints
         pts_in(1,i)=wpts2 (1,i)  ! input points x
         pts_in(2,i)=wpts2 (2,i)  ! input points y
         val_in(1,i)=wflds2(1,i)  ! input fields u
         val_in(2,i)=wflds2(2,i)  ! input fields u
      enddo

c     do i=1,npoints
c        write(6,10) i,pts_in(1,i), pts_in(2,i), val_in(1,i),val_in(2,i)
c     enddo
 10   format(i6,4(e20.10,1x))

      if (nid.eq.0) write(6,*) 'end of reading data.txt'

      if (nid.eq.0) close(106)

      return
      end
c-----------------------------------------------------------------------
      subroutine quick_read_ascii       
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'ACOUSTIC'

      common /rparts/ pts_in(ldim,lpart),val_in(2,lpart)
      common /iparts/ npart,partpt(lpart)
      common /scrns4/ wpts(3,lpart),wpts2(3,lpart),
     $                wflds(2,lpart),wflds2(2,lpart)
      common /ndata/  nxx,nyy,nzz,npoints
      integer         nxx,nyy,nzz,npoints
      real            wpts, wpts2
      

      if (nid.eq.0) open(unit=106,file='data.txt')  
      if (nid.eq.0) write(6,*) 'reading data.txt'       

      call nekgsync

      nxx=  1   !initial set
      nyy=  1   !initial set
      nzz=  1   !initial set
      npoints = nxx*nyy*nzz  ! initial set

      if (nid.eq.0) read (106,*)  nxx,nyy,npoints ! ying's data format                             
      if (nid.eq.0) write(  6,*) 'nxx,nyy,nnz,npoints=',nxx,nyy,nzz,npoints

      npoints2= 2*npoints
      npoints3= 3*npoints

      if (nid.eq.0) then
         if (lpart.lt.npoints) then
             write(6,*) 'set lpart larger than npoints = ',npoints
             call exitt
         endif
      endif

      if (nid.eq.0) then
          do i=1,npoints
            read (106,*)   wpts(1,i),wpts(2,i),wflds(1,i),wflds(2,i)
c           write(  6,*)   wpts(1,i),wpts(2,i),wflds(1,i),wflds(2,i)
          enddo
      else
          call rzero(wpts,npoints3)
      endif

      call gop(wpts ,wpts2 ,'+  ',npoints3)
      call gop(wflds,wflds2,'+  ',npoints2)

c     do i=1,npoints
c        write(6,10) i, wpts(1,i),wpts(2,i),wflds2(1,i),wflds2(2,i)
c     enddo

      do i=1,npoints
         pts_in(1,i)=wpts2 (1,i)  ! input points x
         pts_in(2,i)=wpts2 (2,i)  ! input points y
         val_in(1,i)=wflds2(1,i)  ! input points x
         val_in(2,i)=wflds2(2,i)  ! input points y
      enddo

c     do i=1,npoints
c        write(6,10) i,pts_in(1,i),pts_in(2,i),val_in(1,i),val_in(2,i)
c     enddo
c10   format(i6,4(e20.10,1x))

      if (nid.eq.0) write(6,*) 'done: reading data.txt'

      if (nid.eq.0) close(106)

      return
      end
c-----------------------------------------------------------------------
