c-----------------------------------------------------------------------
c
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
c-----------------------------------------------------------------------
      subroutine usersrc(baseidx,srchx,srchy,srchz,srcex,srcey,srcez)

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'


      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt, myhx, myhy, myhz, myex, myey, myez)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      !include 'ACOUSTIC'
      include 'POISSON' 

      real tt
      real myhx(lx1,ly1,lz1,lelt)
      real myhy(lx1,ly1,lz1,lelt)
      real myhz(lx1,ly1,lz1,lelt)
      real myex(lx1,ly1,lz1,lelt)
      real myey(lx1,ly1,lz1,lelt)
      real myez(lx1,ly1,lz1,lelt)

      do i=1,nx1*ny1*nz1*nelt

         xx=XM1(i,1,1,1)
         yy=YM1(i,1,1,1)
         zz=ZM1(i,1,1,1)

         charge(i) = 2*pi*pi*cos(pi*xx)*cos(pi*yy) ! recper  
         spotent(i)= cos(pi*xx)*cos(pi*yy)

      enddo   

      call poissonq(myex,myey,myez,potent,npts)

      call sub3(epotent,spotent,potent,npts)
      errmax= glamax(epotent,npts)
      if (nid.eq.0) write(6,*) 'poisson: potent_maxerr=',errmax

      call maxwell_grad(myex,myey,myez,potent)
      call chsign(myex,npts)
      call chsign(myey,npts)
      call chsign(myez,npts)

      return
      end

c-----------------------------------------------------------------------
      subroutine usersol(tt, myshx, myshy, myshz, mysex, mysey, mysez)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      real tt
      real myshx(lx1,ly1,lz1,lelt)
      real myshy(lx1,ly1,lz1,lelt)
      real myshz(lx1,ly1,lz1,lelt)
      real mysex(lx1,ly1,lz1,lelt)
      real mysey(lx1,ly1,lz1,lelt)
      real mysez(lx1,ly1,lz1,lelt)

      do i=1,nx1*ny1*nz1*nelv

         xx=xm1(i,1,1,1)
         yy=ym1(i,1,1,1)
         zz=zm1(i,1,1,1)

         mysex(i,1,1,1) = pi*sin(pi*xx)*cos(pi*yy)
         mysey(i,1,1,1) = pi*cos(pi*xx)*sin(pi*yy)
         mysez(i,1,1,1) = 0.0

         myshx(i,1,1,1) = 0
         myshy(i,1,1,1) = 0  !FIXME: solutions for y 
         myshz(i,1,1,1) = 0
      enddo

      return
      end

c-----------------------------------------------------------------------

      subroutine uservp (ix,iy,iz,iel)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy, iz, ieg
      real     one, xcc, ycc, zcc, x1, y1, z1
      real     lambda, fc, wc                     

      call usermedia   (ix,iy,iz,iel)

      if (IFPML)    call userpml   (ix,iy,iz,iel)
      if (IFDRUDE)  call userdrude (ix,iy,iz,iel)

      return
      end

c-----------------------------------------------------------------------

      subroutine usermedia(ix,iy,iz,iel) ! Vector form of userf
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy,iz, ieg
      real     one, xcc, ycc, zcc, x1, y1, z1
      real     lambda, fc, wc                     

      udiff  = 0.
      utrans = 0.

      permea = permea_0             
      permit = permit_0                

      return
      end

c-----------------------------------------------------------------------
      subroutine userdrude(ix,iy,iz,iel) ! Vector form of userf

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      return
      end

c-----------------------------------------------------------------------

      subroutine userpml(ix,iy,iz,iel) ! Vector form of userf
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      return
      end

c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer ix, iy, iz, ieg
C
      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
C
      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
C
      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux=0.0
      uy=0.0
      uz=0.0
      temp=0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      return
      end

c-----------------------------------------------------------------------
      subroutine usrdat2

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  e

      n    = nx1*ny1*nz1*nelv

c     ifxyo= .true.

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)
      zmin = glmin(zm1,n)
      zmax = glmax(zm1,n)

c     if (nid.eq.0) write(6,*) wavenumber,' This is wavenumber'


      if (if3d) then
      do i = 1,n
      sx = 2/(xmax-xmin)
      sy = 2/(ymax-ymin)
      sz = 2/(zmax-zmin)
         xm1(i,1,1,1)=sx*(xm1(i,1,1,1)-xmin)-1
         ym1(i,1,1,1)=sy*(ym1(i,1,1,1)-ymin)-1
         zm1(i,1,1,1)=sz*(zm1(i,1,1,1)-zmin)-1
      enddo
      else
      do i = 1,n
      sx = 2/(xmax-xmin)
      sy = 2/(ymax-ymin)
         xm1(i,1,1,1)=sx*(xm1(i,1,1,1)-xmin)  
         ym1(i,1,1,1)=sy*(ym1(i,1,1,1)-ymin)  

      enddo       
      endif

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)

c...  assign different integer for different wavenumber
      xfix = (xmax+xmin)/2.0
      yfix = (ymax+ymin)/2.0

      do e=1,nelt

         yymax= vlmax(ym1(1,1,1,e),nxyz)
         yymin= vlmin(ym1(1,1,1,e),nxyz)
         yymid= (yymax+yymin)/2.0

         if (yymid.lt.yfix) then
             if_in_region(e)=1  ! bottom layer: change accordingly in lines 45-60
         else
             if_in_region(e)=2  ! top layer: change accordingly in lines 45-60
         endif

      enddo

c...  deformation along yfix
      scale=0.1
      do e=1,nelt
      do i=1,nxyz
         xx= xm1(i,1,1,e)
         yy= ym1(i,1,1,e)
         sc= scale*cos(pi*xx)
         if     (if_in_region(e).eq.1) then
             ym1(i,1,1,e) = (sc-ymin)*(yy-ymin)/(yfix-ymin)+ymin
         elseif (if_in_region(e).eq.2) then
             ym1(i,1,1,e) = (ymax-sc)*(yy-yfix)/(ymax-yfix)+sc
         endif
      enddo
      enddo

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)

      if (nid.eq.0) write(6,*) 'xmin/xmax/ymin/ymax',xmin,xmax,ymin,ymax

      return
      end

c-----------------------------------------------------------------------
      subroutine userft           
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk(docleanup)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      logical docleanup

      common /ccpu/ cpu_t,cpu_t0
      COMMON /ERR /  ErrHX(LX1,LY1,LZ1,LELT)
     $             , ErrHY(LX1,LY1,LZ1,LELT)
     $             , ErrHZ(LX1,LY1,LZ1,LELT)
     $             , ErrEX(LX1,LY1,LZ1,LELT)
     $             , ErrEY(LX1,LY1,LZ1,LELT)
     $             , ErrEZ(LX1,LY1,LZ1,LELT)
      
      integer errunit
      parameter (errunit=77)

c     Helper for initialize-once variables
      logical icalld
      data icalld/.false./
      save icalld

      if ((.not.icalld).and.(nid.eq.0)) then
        icalld = .true.

        open (errunit,file='runlog.dat',status='new')
        write(errunit,*) 'NEKTON run log'
      endif

      if (docleanup) then
        close(errunit)
        return
      endif

c ... compute errors

      if (istep.le.10.or.mod(istep,iocomm).eq.0) then

        ntott = nx1*ny1*nz1*nelt
        nsrf  = nx1*nz1*nelt*6

        if (ifsol) then
          call usersol(time,shx,shy,shz,sex,sey,sez)
        else
          call rzero(shx, ntott) 
          call rzero(shy, ntott) 
          call rzero(shz, ntott) 
          call rzero(sex, ntott) 
          call rzero(sey, ntott) 
          call rzero(sez, ntott) 
        endif

        call sub3(ErrHX,SHX,HX,NTOTT) 
        call sub3(ErrHY,SHY,HY,NTOTT) 
        call sub3(ErrHZ,SHZ,HZ,NTOTT) 
        call sub3(ErrEX,SEX,EX,NTOTT) 
        call sub3(ErrEY,SEY,EY,NTOTT) 
        call sub3(ErrEZ,SEZ,EZ,NTOTT) 

        HXmr = glamax(ErrHX,NTOTT) 
        HYmr = glamax(ErrHY,NTOTT) 
        HZmr = glamax(ErrHZ,NTOTT) 
        EXmr = glamax(ErrEX,NTOTT) 
        EYmr = glamax(ErrEY,NTOTT) 
        EZmr = glamax(ErrEZ,NTOTT) 

        HXer = glsc3(ErrHX,bm1,ErrHX,NTOTT) / volvm1
        HYer = glsc3(ErrHY,bm1,ErrHY,NTOTT) / volvm1
        HZer = glsc3(ErrHZ,bm1,ErrHZ,NTOTT) / volvm1
        EXer = glsc3(ErrEX,bm1,ErrEX,NTOTT) / volvm1
        EYer = glsc3(ErrEY,bm1,ErrEY,NTOTT) / volvm1
        EZer = glsc3(ErrEZ,bm1,ErrEZ,NTOTT) / volvm1

        if (hxer.gt.0) hxer = sqrt(hxer)
        if (hyer.gt.0) hyer = sqrt(hyer)
        if (hzer.gt.0) hzer = sqrt(hzer)
        if (exer.gt.0) exer = sqrt(exer)
        if (eyer.gt.0) eyer = sqrt(eyer)
        if (ezer.gt.0) ezer = sqrt(ezer)


c ... compute max gap size at interfaces between elmts.

        HXgp = glamax(gHX,NSRF) 
        HYgp = glamax(gHY,NSRF) 
        HZgp = glamax(gHZ,NSRF) 
        EXgp = glamax(gEX,NSRF) 
        EYgp = glamax(gEY,NSRF) 
        EZgp = glamax(gEZ,NSRF) 

c ... print statement

        snel = nelt + .5
        snel = sqrt(snel)
        nels = snel
        nnn  = nx1-1
        npt1 = nnn*nels
        npts = nx1*ny1*nz1*nelt ! npts = npt1**ndim
        wavelength = param(69)*nmscale

	if (wavelength.ne.0) then
            tpw  = time/wavelength
        else
            tpw  = 0.0                 
        endif 

        if (nid.eq.0) then

          h2err = hxer**2 + hyer**2
          if (h2err.gt.0) h2err = sqrt(h2err)
          hmgp = max(hxgp,hygp)
          hmer = max(hxmr,hymr)

          write(6,91) ISTEP,nelt,nels,nnn,npt1,npts
     $               ,time,dt,HXer,HYer,HZer,EXer,EYer,EZer,cpu_t,tpw
          write(6,95) ISTEP,nelt,nels,nnn,npt1,npts
     $               ,time,dt,HXmr,HYmr,HZmr,EXmr,EYmr,EZmr,cpu_t,tpw

 91       format(/,i5,3i5,i5,i9,1p9e10.3,e9.2,' CPU: L2  ')
 95       format(/,i5,3i5,i5,i9,1p9e10.3,e9.2,' CPU: Linf')

          ! write errors to file
          write(errunit,61) 'L2',istep,HXer,HYer,HZer,EXer,EYer,EZer
          write(errunit,61) 'Linf', istep,HXmr,HYmr,HZmr,EXmr,EYmr,EZmr
          write(errunit,62) istep,cpu_t

 61       format('errors ',A,i9,' hx:',e20.9,' hy:',e20.9,' hz:',e20.9,
     $                          ' ex:',e20.9,' ey:',e20.9,' ez:',e20.9)
 62       format('time ',i5,e20.9)

          write(18,93) ISTEP,EZer
 93       format(i7,1pe10.3)

        endif ! nid=0

      endif


      return
      end





