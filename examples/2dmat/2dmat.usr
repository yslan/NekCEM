c-----------------------------------------------------------------------
c
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - ADEs for surface current density
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine userinc
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt, myhx, myhy, myhz, myex, myey, myez)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      real tt
      real myhx(lx1,ly1,lz1,lelt)
      real myhy(lx1,ly1,lz1,lelt)
      real myhz(lx1,ly1,lz1,lelt)
      real myex(lx1,ly1,lz1,lelt)
      real myey(lx1,ly1,lz1,lelt)
      real myez(lx1,ly1,lz1,lelt)
      integer i,j,k,l

      call rzero(myhx, n)
      call rzero(myhy, n)
      call rzero(myhz, n)
      call rzero(myex, n)
      call rzero(myey, n)
      call rzero(myez, n)

      call cem_current_bc_ptr

      return
      end
c-----------------------------------------------------------------------
      subroutine usersol(tt, myshx, myshy, myshz, mysex, mysey, mysez)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'GEOMBOUND'

      real tt
      real myshx(lx1,ly1,lz1,lelt)
      real myshy(lx1,ly1,lz1,lelt)
      real myshz(lx1,ly1,lz1,lelt)
      real mysex(lx1,ly1,lz1,lelt)
      real mysey(lx1,ly1,lz1,lelt)
      real mysez(lx1,ly1,lz1,lelt)

      return
      end
c-----------------------------------------------------------------------
      subroutine usersrc(baseidx,srchx,srchy,srchz,srcex,srcey,srcez)
c-----------------------------------------------------------------------
c     Add source terms to the fields given in src{e,h}{x,y,z}. Read file
c     doc/rea-file.txt for specification. Since we want to make it
c     possible to have several sources, we specify a `baseidx', relative
c     to which all parameters are read.
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'
      include 'RK5'

      integer baseidx

      real srchx(lx1,ly1,lz1,lelt),
     $     srchy(lx1,ly1,lz1,lelt),
     $     srchz(lx1,ly1,lz1,lelt),
     $     srcex(lx1,ly1,lz1,lelt),
     $     srcey(lx1,ly1,lz1,lelt),
     $     srcez(lx1,ly1,lz1,lelt)

      ! Extent of domain
      integer nxyzl
      save    nxyzl

      real    xsize, ysize, zsize
      save    xsize, ysize, zsize
      real    xmin, xmax, ymin, ymax, zmin, zmax
      save    xmin, xmax, ymin, ymax, zmin, zmax

      integer icalld
      save    icalld
      data    icalld /0/             

      integer fldchs

      real    xx, yy, zz
      real    xloc,yloc,zloc,xw,yw,zw,xwidth,ywidth,zwidth          
      real    xgauss, ygauss, zgauss
      real    kx , ky , kz 
      real    twopi
      real    tconst,tfactor,fldhere
      real    wavelength
      real    temporal_freq

c     Presetting
      twopi  = 2.0*pi

c     Spatial mode set
      xloc  = 0.0 ! param(66); smodty = 2: gaussian 
      yloc  = 1.5 ! param(67)          
      zloc  = 0.0 ! param(68)             
      xw    = 0.0 ! param(69)  
      yw    = 0.0 ! param(70)  
      zw    = 0.0 ! param(71)  
      xwidth= 1 ! param(72)          
      ywidth= 1 ! param(73)            
      zwidth= 1 ! param(74)            
c     Spatial mode set  
      kx    = 0.0 ! param(66); smodty = 3: planewave
      ky    = 0.0 ! param(67)                  
      kz    = 0.0 ! param(68)              

      wavelength = nmscale  ! param(69)*nmscale
      temporal_freq = cspeed ! param(64)*cspeed; tmodty = 3: cosine pulse

c     Evaluate temporal modulation.
      call cosine_pulse (tfactor,rktime,twopi,temporal_freq)

c     Evaluate spatial modulation.
      xgauss = xloc + xw*rktime                                       
      ygauss = yloc + yw*rktime                                       
      zgauss = zloc + zw*rktime                                       

      npts = nx1*ny1*nz1*nelt
      do i = 1,npts         
         xx = xm1(i,1,1,1)
         yy = ym1(i,1,1,1)
         zz = zm1(i,1,1,1)

         tconst  = tfactor*bm1(i,1,1,1) ! *fldhere

         src_x = exp(-(2.0*(xx-xgauss)/xwidth)**2)   
         src_y = exp(-(2.0*(yy-ygauss)/ywidth)**2)
         src_z = exp(-(2.0*(zz-zgauss)/zwidth)**2)

         inchn(i,1) = 0                  
         inchn(i,2) = 0                  
         inchn(i,3) = src_x*src_y*src_z              
         incen(i,1) = 0                  
         incen(i,2) = 0                  
         incen(i,3) = 0                  
         fullary(i,1,1,1) = tconst*inchn(i,3)            
      enddo

c     Add fullary to selected field
      fldchs=3

      if (fldchs.eq.1) call fadd2(srchx,fullary,npts)
      if (fldchs.eq.2) call fadd2(srchy,fullary,npts)
      if (fldchs.eq.3) call fadd2(srchz,fullary,npts)
      if (fldchs.eq.4) call fadd2(srcex,fullary,npts)
      if (fldchs.eq.5) call fadd2(srcey,fullary,npts)
      if (fldchs.eq.6) call fadd2(srcez,fullary,npts)

      return
      end
c-----------------------------------------------------------------------
      subroutine gussian_pulse(tfactor,tt,param1,param2)
c-----------------------------------------------------------------------
      real tfactor,tt,param

      tfactor = exp(-(2.0*(tt-param1)/param2)**2)

      return
      end
c-----------------------------------------------------------------------
      subroutine cosine_pulse(tfactor,tt,twopi,param1)
c-----------------------------------------------------------------------
      real tfacfor,tt,twopi,param1

      tfactor= cos(twopi*param1*tt)             

      return
      end
c-----------------------------------------------------------------------
      subroutine rectangular_pulse(tfactor,tt,param1)
c-----------------------------------------------------------------------
      real tfacfor,tt,param1

      if (mod(tt,param1).le.0.5*param1) then
          tfactor = 1.
      else
          tfactor = 0. 
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp(ix,iy,iz,ielg)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer ix,iy,iz,ielg,iel
      
c     Get local element number from global element number
      iel = gllel(ielg)

      if (if_in_region(iel).eq.30) then
c     Upper region
         permit_r = 1.0
         permea_r = 1.0
      else
c     Lower region
         permit_r = 1.0
         permea_r = 1.0
      endif
      permit = permit_r*permit_0
      permea = permea_r*permea_0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux=0.0
      uy=0.0
      uz=0.0
      temp=0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      return
      end

c-----------------------------------------------------------------------
      subroutine usrdat2
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'GEOMBOUND'

      n = nx1*ny1*nz1*nelv

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)
      zmin = glmin(zm1,n)
      zmax = glmax(zm1,n)

      nmscale = 1.0 ! 2*pi/(xmax-xmin); nanoscale
      sx = 5.0*nmscale ! 2*pi/(xmax-xmin)
      sy = 5.0*nmscale ! 2*pi/(ymax-ymin)       
      if (if3d) sz =5.0*nmscale ! 2.0*pi/(zmax-zmin)

      if (if3d) then
         do i = 1,n
            xm1(i,1,1,1) = sx*(xm1(i,1,1,1)-xmin)/(xmax-xmin)-2.5
            ym1(i,1,1,1) = sy*(ym1(i,1,1,1)-ymin)/(ymax-ymin)-2.5
            zm1(i,1,1,1) = sz*(zm1(i,1,1,1)-zmin)/(zmax-zmin)-2.5
         enddo
      else
         do i = 1,n
            xm1(i,1,1,1) = sx*(xm1(i,1,1,1)-xmin)/(xmax-xmin)-2.5
            ym1(i,1,1,1) = sy*(ym1(i,1,1,1)-ymin)/(ymax-ymin)-2.5
         enddo
      endif

      nxy2 = nx1/2.0
      do ie = 1,nelv
         xmid = xm1(nxy2,nxy2,1,ie)
         ymid = ym1(nxy2,nxy2,1,ie)
         zmid = zm1(nxy2,nxy2,1,ie)
         rmd2 = xmid*xmid + ymid*ymid

         if (ymid.gt.0) then
c     Upper region
            if_in_region(ie) = 30
         else
c     Lower region
            if_in_region(ie) = 10
         endif
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userft
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      common /ccpu/ cpu_t,cpu_dtime,cpu_chk

c ... compute errors

      if (istep.le.10.or.mod(istep,iocomm).eq.0) then

        ntott = nx1*ny1*nz1*nelt
        npts3 = nx1*ny1*nz1*nelt*3
        nsrf  = nx1*nz1*nelt*6

        if (ifsol) then
          call usersol(time,sHN(1,1),sHN(1,2),sHN(1,3),
     $                      sEN(1,1),sEN(1,2),sEN(1,3))
        else
          call rzero(sHN, npts3) 
          call rzero(sEN, npts3) 
        endif

        call sub3(ErrHN(1,1),SHN(1,1),HN(1,1),NTOTT)
        call sub3(ErrHN(1,2),SHN(1,2),HN(1,2),NTOTT)
        call sub3(ErrHN(1,3),SHN(1,3),HN(1,3),NTOTT)
        call sub3(ErrEN(1,1),SEN(1,1),EN(1,1),NTOTT)
        call sub3(ErrEN(1,2),SEN(1,2),EN(1,2),NTOTT)
        call sub3(ErrEN(1,3),SEN(1,3),EN(1,3),NTOTT)

        HXmr = glamax(ErrHN(1,1),NTOTT)
        HYmr = glamax(ErrHN(1,2),NTOTT)
        HZmr = glamax(ErrHN(1,3),NTOTT)
        EXmr = glamax(ErrEN(1,1),NTOTT)
        EYmr = glamax(ErrEN(1,2),NTOTT)
        EZmr = glamax(ErrEN(1,3),NTOTT)
 
        HXer = glsc3(ErrHN(1,1),bm1,ErrHN(1,1),NTOTT)/ volvm1
        HYer = glsc3(ErrHN(1,2),bm1,ErrHN(1,2),NTOTT)/ volvm1
        HZer = glsc3(ErrHN(1,3),bm1,ErrHN(1,3),NTOTT)/ volvm1
        EXer = glsc3(ErrEN(1,1),bm1,ErrEN(1,1),NTOTT)/ volvm1
        EYer = glsc3(ErrEN(1,2),bm1,ErrEN(1,2),NTOTT)/ volvm1
        EZer = glsc3(ErrEN(1,3),bm1,ErrEN(1,3),NTOTT)/ volvm1

        if (hxer.gt.0) hxer = sqrt(hxer)
        if (hyer.gt.0) hyer = sqrt(hyer)
        if (hzer.gt.0) hzer = sqrt(hzer)
        if (exer.gt.0) exer = sqrt(exer)
        if (eyer.gt.0) eyer = sqrt(eyer)
        if (ezer.gt.0) ezer = sqrt(ezer)

c ... print statement

        snel = nelt + .5
        snel = sqrt(snel)
        nels = snel
        nnn  = nx1-1
        npt1 = nnn*nels
        npts = nx1*ny1*nz1*nelt ! npts = npt1**ndim

        if (istep.eq.0)       cpu_p_t= 0
        if (istep.gt.0)       cpu_p_t= cpu_t/(npts*istep)
        if (istep.eq.nsteps)  cpu_p_t= glsum(cpu_p_t,1)/np

c$$$        if (nid.eq.0) then
c$$$
c$$$         if (istep.eq.1) write(6,90)
c$$$         write(6,91) ISTEP,nelt,nels,nnn,npt1,npts
c$$$     $         ,time,dt,HXer,HYer,HZer,EXer,EYer,EZer,cpu_t,cpu_p_t
c$$$         write(6,95) ISTEP,nelt,nels,nnn,npt1,npts
c$$$     $         ,time,dt,HXmr,HYmr,HZmr,EXmr,EYmr,EZmr,cpu_t,cpu_p_t
c$$$
c$$$
c$$$ 90      format(/,'    istep   nelt  nels  N  npt1    npts   time
c$$$     $  dt     HXerr     HYerr     HZerr     EXerr     EYerr     EZerr
c$$$     $  cpu_t   cpu_t_pts')
c$$$ 91      format(/,i10,3i5,i5,i9,1p9e10.3,e9.2,' CPU: L2  '  )
c$$$ 95      format(  i10,3i5,i5,i9,1p9e10.3,e9.2,' CPU: Linf'  )
c$$$
c$$$
c$$$        endif ! nid=0

      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine cem_2dmaterial_currents
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      integer  i,j,k
      real     a_d,b_d
      real     a_211,a_221,b_11,b_21
      real     a_212,a_222,b_12,b_22

c     FIXME: figure out Drude coefficients
      a_d = 1.0
      b_d = 1.0

      a_211 = 0.463
      a_221 = 1.091
      b_11 = -0.0012
      b_21 = -0.00026

      a_212 = 0.585
      a_222 = 1.238
      b_12 = -0.0029
      b_22 = -0.00049

      k = 1
      i = cemcur(k)
      j = cemface(i)
      write(*,*) 'JJJ', JN1(j,1), PN2(j,1), PN3(j,1)

      do k = 1,ncemcur
c     i is the face global number
         i = cemcur(k)
c     j is the volume global number associated with face i
         j = cemface(i)

c     TE wave, so the only tangential component of the E field is E_y.
c     Therefore we only need to fill one component of the current.

c     Drude term
         resJN1(j,1) = -a_d*JN1(j,1) + b_d*EN(j,1)
c     First critical point term
         resPN2(j,1) = QN2(j,1) + b_11*EN(j,1)
	 resQN2(j,1) = -a_211*PN2(j,1) - a_221*QN2(j,1) + b_21*EN(j,1)
c     Second critical point term
         resPN3(j,1) = QN3(j,1) + b_12*EN(j,1)
	 resQN3(j,1) = -a_212*PN3(j,1) - a_222*QN3(j,1) + b_22*EN(j,1)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine cem_total_current
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      integer i,j,k
      real b_cp1,b_cp2

      b_cp1 = -0.0022
      b_cp2 = -0.0051
      
      do k = 1,ncemcur
         i = cemcur (k)
         j = cemface(i)
         JN(j,1) = JN1(j,1) !+ PN2(j,1) - b_cp1*EN(j,1)
!     $        + PN3(j,1) - b_cp2*EN(j,1)
         JN(j,2) = JN1(j,2) + PN2(j,2) - b_cp1*EN(j,2)
     $        + PN3(j,2) - b_cp2*EN(j,2)
         JN(j,3) = JN1(j,3) + PN2(j,3) - b_cp1*EN(j,3)
     $        + PN3(j,3) - b_cp2*EN(j,3)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine cem_current_restrict_to_face
c-----------------------------------------------------------------------
c     Restrict current to faces.
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      do j = 1,ncemface
         i = cemface(j)
         fJN(j,1) = JN(i,1)
         fJN(j,2) = JN(i,2)
         fJN(j,3) = JN(i,3)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine cem_current_on_face
c-----------------------------------------------------------------------
c     Set the surface current.
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      do i=1,ncemcur
         j = cemcur(i)

c        fJN1(j,1) = define current 
c        fJN1(j,2) = define current 
c        fJN1(j,3) = define current 
c        fJN2(j,1) = define current 
c        fJN2(j,2) = define current 
c        fJN2(j,3) = define current 
c        fJN3(j,1) = define current 
c        fJN3(j,2) = define current 
c        fJN3(j,3) = define current 
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine cem_current_bc_ptr
c----------------------------------------------------------------------- 
      implicit none
      include 'SIZE'
      include 'GEOM'
      include 'INPUT'
      include 'TOPOL'
      include 'EMWAVE'
      include 'PARALLEL'
      include 'NEKUSE'

      real      srflx(1)
      integer   i,j,k,e,f
      character CB*3

c$$$      k = 0
c$$$      do e= 1,nelt
c$$$      do f= 1,nfaces
c$$$      do j= 1,nx1*nz1
c$$$
c$$$         CB = CBC(f,e,1)
c$$$
c$$$         i =(e-1)*2*ndim*nx1*nz1+(f-1)*nx1*nz1+j
c$$$
c$$$         if ((CB.eq.'J  ').or.(CB.eq.'j  ')) then
c$$$            k=k+1
c$$$            cemcur(k)= i
c$$$            ncemcur  = k
c$$$  endif
c$$$      enddo
c$$$      enddo
c$$$      enddo

      k = 0
      do j = 1,ncemface
         if (facef(j).eq.40.0) then
            k = k + 1
            cemcur(k) = j
         endif
      enddo
      ncemcur = k

      return
      end
c-----------------------------------------------------------------------
      subroutine prescribe_en
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'RK5'

      integer i,j,k
      real xx,yy,zz
      
      do k = 1,ncemcur
         i = cemcur (k)
         j = cemface(i)
         xx = xm1(i,1,1,1)
         yy = ym1(i,1,1,1)
         zz = zm1(i,1,1,1)
c     Add some spatial dependencies to try and smoke out bugs.
c     Time frequency is omega = 1.
         EN(j,2) = cos(rktime)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine test_current
c-----------------------------------------------------------------------
c     Prescribe a time-harmonic E field on the conducting faces and make
c     sure the RK solver gets the correct current. We know that the
c     exact solution should be sigma(omega) * n x (E x n) where sigma is
c     the conductivity.
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'RK5'
      real ca,cb
      real tmp,err,maxerr
      integer i,j,k

      do i = 1,5
c     5-stage 4th-order RK.
c     Note the order of the steps carefully!
         call rk_c(i)

         call prescribe_en
         call cem_2dmaterial_currents

         ca = rk4a(i)
         cb = rk4b(i)
         call rk4_upd(JN1(1,1),kJN1(1,1),resJN1(1,1),cb,ca,dt,npts)
         call rk4_upd(PN2(1,1),kPN2(1,1),resPN2(1,1),cb,ca,dt,npts)
         call rk4_upd(PN3(1,1),kPN3(1,1),resPN3(1,1),cb,ca,dt,npts)
         call rk4_upd(QN2(1,1),kQN2(1,1),resQN2(1,1),cb,ca,dt,npts)
         call rk4_upd(QN3(1,1),kQN3(1,1),resQN3(1,1),cb,ca,dt,npts)

         call cem_total_current
      enddo

      return
      end
c-----------------------------------------------------------------------
