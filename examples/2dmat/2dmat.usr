c-----------------------------------------------------------------------
c
c  User specified routines:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine userinc
c-----------------------------------------------------------------------
c     Use this subroutine to compute the incident field.
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'RK5'

      common /userparam/ omega,eps1,eps2,mu1,mu2,sigmagraph,refl,tran
      real omega,eps1,eps2,mu1,mu2
      complex sigmagraph,refl,tran

      integer i,j,k
      real ky
      real yy,tt,mu,eps,uinc
      complex CI
      parameter (CI = (0.0,1.0))

      tt = rktime
      do i = 1,ncemincfld
         j = cemincfld(i)
         k = cemface(j)
         yy = ym1(k,1,1,1)
         eps = permittivity(k)
         mu = permeability(k)
         ky = omega*sqrt(mu*eps)
         uinc = dble(cexp(CI*(-ky*yy-omega*tt)))
         fHN(j,3) = fHN(j,3)+uinc
         fEN(j,1) = fEN(j,1)+ky*uinc/(eps*omega)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt,myhx,myhy,myhz,myex,myey,myez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      common /userparam/ omega,eps1,eps2,mu1,mu2,sigmagraph,refl,tran
      real omega,eps1,eps2,mu1,mu2
      complex sigmagraph,refl,tran

      integer i,j,k
      real tt,yy
      real myhx(lx1,ly1,lz1,lelt)
      real myhy(lx1,ly1,lz1,lelt)
      real myhz(lx1,ly1,lz1,lelt)
      real myex(lx1,ly1,lz1,lelt)
      real myey(lx1,ly1,lz1,lelt)
      real myez(lx1,ly1,lz1,lelt)
      complex z1,cqn2,cpn2,cqn3,cpn3,enpar,CI
      parameter (CI = (0.0,1.0))

      call usersol(tt,myhx,myhy,myhz,myex,myey,myez)

c     We also have to initialize all of the currents
      z1 = sqrt(mu1/eps1)
c     Parallel part of the E field at the interface (complex form)
      enpar = z1*(refl-1)
      do i = 1,ncemcur
         j = cemcur(i)
         jn1(j,1) = dble(b_d/(a_d-CI*omega))*enpar
         cqn2 = -((a_211*b_11+CI*omega*b_21)
     $        /(omega**2+a_211-CI*omega*a_221))*enpar
         cpn2 = (CI/omega)*(cqn2+b_11*enpar)
         cqn3 = -((a_212*b_12+CI*omega*b_22)
     $        /(omega**2+a_212-CI*omega*a_222))*enpar
         cpn3 = (CI/omega)*(cqn3+b_12*enpar)

         qn2(j,1) = dble(cqn2)
         pn2(j,1) = dble(cpn2)
         qn3(j,1) = dble(cqn3)
         pn3(j,1) = dble(cpn3)
         jn(j,1) = jn1(j,1) + pn2(j,1) + pn3(j,1)
     $        - dble((b_cp1+b_cp2)*enpar)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usersol(tt,myshx,myshy,myshz,mysex,mysey,mysez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'GEOMBOUND'

      common /userparam/ omega,eps1,eps2,mu1,mu2,sigmagraph,refl,tran
      real omega,eps1,eps2,mu1,mu2
      complex sigmagraph,refl,tran
      
      real tt
      real myshx(lx1,ly1,lz1,lelt)
      real myshy(lx1,ly1,lz1,lelt)
      real myshz(lx1,ly1,lz1,lelt)
      real mysex(lx1,ly1,lz1,lelt)
      real mysey(lx1,ly1,lz1,lelt)
      real mysez(lx1,ly1,lz1,lelt)

      integer e,i,j,l,lx1_2
      real ky
      real yy,mu,eps
      complex CI
      parameter (CI = (0.0,1.0))

      lx1_2 = lx1/2
      do e = 1,nelt
         do i = 1,lx1
            do j = 1,ly1
c     Global number
               l = i+nx1*(j-1)+nx1*ny1*nz1*(e-1)
               eps = permittivity(l)
               mu = permeability(l)
               ky = omega*sqrt(eps*mu)
               yy = ym1(i,j,1,e)
               if (ym1(lx1_2,lx1_2,1,e).gt.0.0) then
                  myshz(i,j,1,e) = dble(refl*cexp(CI*(ky*yy-omega*tt)))
                  mysex(i,j,1,e) = -(ky/(eps*omega))*myshz(i,j,1,e)
               else
                  myshz(i,j,1,e) = dble(tran*cexp(CI*(-ky*yy-omega*tt)))
                  mysex(i,j,1,e) = (ky/(eps*omega))*myshz(i,j,1,e)
               endif
            enddo
         enddo
      enddo
                  
      return
      end
c-----------------------------------------------------------------------
      subroutine usersrc(baseidx,srchx,srchy,srchz,srcex,srcey,srcez)
c-----------------------------------------------------------------------
c     Add source terms to the fields given in src{e,h}{x,y,z}. Read file
c     doc/rea-file.txt for specification. Since we want to make it
c     possible to have several sources, we specify a `baseidx', relative
c     to which all parameters are read.
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'
      include 'RK5'

      integer baseidx

      real srchx(lx1,ly1,lz1,lelt),
     $     srchy(lx1,ly1,lz1,lelt),
     $     srchz(lx1,ly1,lz1,lelt),
     $     srcex(lx1,ly1,lz1,lelt),
     $     srcey(lx1,ly1,lz1,lelt),
     $     srcez(lx1,ly1,lz1,lelt)

      ! Extent of domain
      integer nxyzl
      save    nxyzl

      real    xsize, ysize, zsize
      save    xsize, ysize, zsize
      real    xmin, xmax, ymin, ymax, zmin, zmax
      save    xmin, xmax, ymin, ymax, zmin, zmax

      integer icalld
      save    icalld
      data    icalld /0/             

      integer fldchs

      real    xx, yy, zz
      real    xloc,yloc,zloc,xw,yw,zw,xwidth,ywidth,zwidth          
      real    xgauss, ygauss, zgauss
      real    kx , ky , kz 
      real    twopi
      real    tconst,tfactor,fldhere
      real    wavelength
      real    temporal_freq

c     Presetting
      twopi  = 2.0*pi

c     Spatial mode set
      xloc  = 0.0 ! param(66); smodty = 2: gaussian 
      yloc  = 1.5 ! param(67)          
      zloc  = 0.0 ! param(68)             
      xw    = 0.0 ! param(69)  
      yw    = 0.0 ! param(70)  
      zw    = 0.0 ! param(71)  
      xwidth= 1 ! param(72)          
      ywidth= 1 ! param(73)            
      zwidth= 1 ! param(74)            
c     Spatial mode set  
      kx    = 0.0 ! param(66); smodty = 3: planewave
      ky    = 0.0 ! param(67)                  
      kz    = 0.0 ! param(68)              

      wavelength = nmscale  ! param(69)*nmscale
      temporal_freq = cspeed ! param(64)*cspeed; tmodty = 3: cosine pulse

c     Evaluate temporal modulation.
      call cosine_pulse (tfactor,rktime,twopi,temporal_freq)

c     Evaluate spatial modulation.
      xgauss = xloc + xw*rktime                                       
      ygauss = yloc + yw*rktime                                       
      zgauss = zloc + zw*rktime                                       

      npts = nx1*ny1*nz1*nelt
      do i = 1,npts         
         xx = xm1(i,1,1,1)
         yy = ym1(i,1,1,1)
         zz = zm1(i,1,1,1)

         tconst  = tfactor*bm1(i,1,1,1) ! *fldhere

         src_x = exp(-(2.0*(xx-xgauss)/xwidth)**2)   
         src_y = exp(-(2.0*(yy-ygauss)/ywidth)**2)
         src_z = exp(-(2.0*(zz-zgauss)/zwidth)**2)

         if (imode.eq.1) then
c     TE case
            inchn(i,1) = 0
            inchn(i,2) = 0
            inchn(i,3) = src_x*src_y*src_z
            incen(i,1) = 0
            incen(i,2) = 0
            incen(i,3) = 0
            fullary(i,1,1,1) = tconst*inchn(i,3)
         elseif (imode.eq.2) then
c     TM case
            inchn(i,1) = 0
            inchn(i,2) = 0
            inchn(i,3) = 0
            incen(i,1) = 0
            incen(i,2) = 0
            incen(i,3) = src_x*src_y*src_z
            fullary(i,1,1,1) = tconst*incen(i,3)
         else
            write(*,*) 'ERROR: invalid imode in usersrc'
            call exitt
         endif
      enddo

c     Add fullary to selected field
      if (imode.eq.1) then
         fldchs = 3
      else
         fldchs = 6
      endif

      if (fldchs.eq.1) call fadd2(srchx,fullary,npts)
      if (fldchs.eq.2) call fadd2(srchy,fullary,npts)
      if (fldchs.eq.3) call fadd2(srchz,fullary,npts)
      if (fldchs.eq.4) call fadd2(srcex,fullary,npts)
      if (fldchs.eq.5) call fadd2(srcey,fullary,npts)
      if (fldchs.eq.6) call fadd2(srcez,fullary,npts)

      return
      end
c-----------------------------------------------------------------------
      subroutine cosine_pulse(tfactor,tt,twopi,param1)
c-----------------------------------------------------------------------
      real tfacfor,tt,twopi,param1

      tfactor = cos(twopi*param1*tt)             

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp(ix,iy,iz,ielg)
c-----------------------------------------------------------------------
c     Use this routine to set material properties.
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      common /userparam/ omega,eps1,eps2,mu1,mu2,sigmagraph,refl,tran
      real omega,eps1,eps2,mu1,mu2
      complex sigmagraph,refl,tran
    
      integer ix,iy,iz,ielg,iel

c     Get local element number from global element number
      iel = gllel(ielg)

      if (if_in_region(iel).eq.1) then
c     Upper region
         permit_r = eps1
         permea_r = mu1
      elseif (if_in_region(iel).eq.2) then
c     Lower region
         permit_r = eps2
         permea_r = mu2
      else
         write(*,*) 'Invalid region number in uservp'
         call exitt
      endif
      permit = permit_r*permit_0
      permea = permea_r*permea_0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux = 0.0
      uy = 0.0
      uz = 0.0
      temp = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
c-----------------------------------------------------------------------
c     For now piggy-back on this routine to set parameters that we need
c     for the incident field/exact solution.
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      common /userparam/
     $     omega,               ! frequency of the incident wave
     $     eps1,                ! permittivity in upper region
     $     eps2,                ! permittivity in lower region
     $     mu1,                 ! permeability in upper region
     $     mu2,                 ! permeability in lower region
     $     sigmagraph,          ! complex conductivity
     $     refl,                ! complex reflection coefficient
     $     tran                 ! complex transmission coefficient

      real omega
      real eps1,eps2,mu1,mu2
      complex sigmagraph,csigma_d,csigma_cp1,csigma_cp2
      complex refl,tran,z1,z2,CI
      parameter (CI = (0.0,1.0))

      omega = 5.0
      eps1 = 1.0
      eps2 = 1.0
      mu1 = 1.0
      mu2 = 1.0

      csigma_d = b_d/(a_d-CI*omega)
      csigma_cp1 = (CI/omega)*((-a_211*b_11+CI*omega*b_21)
     $     /(omega**2+a_211-CI*omega*a_221)+b_11)-b_cp1
      csigma_cp2 = (CI/omega)*((-a_212*b_12+CI*omega*b_22)
     $     /(omega**2+a_212-CI*omega*a_222)+b_12)-b_cp2
      sigmagraph = csigma_d + csigma_cp1 + csigma_cp2

      z1 = sqrt(mu1/eps1)
      z2 = sqrt(mu2/eps2)
      refl = (z1 - z2 + sigmagraph*z1*z2)/(z1 + z2 + sigmagraph*z1*z2)
      tran = 2*z1/(z1 + z2 + sigmagraph*z1*z2)

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
c-----------------------------------------------------------------------
c     Use this subroutine to set the dimensions of the domain.
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'GEOMBOUND'

      integer e,f,i,j,n,nxy2
      real glmin,glmax
      real sx,sy,sz,xmid,ymid,zmid

      n = nx1*ny1*nz1*nelv

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)
      zmin = glmin(zm1,n)
      zmax = glmax(zm1,n)

      nmscale = 1.0
      sx = 5.0*nmscale
      sy = 5.0*nmscale
      if (if3d) sz = 5.0*nmscale

      if (if3d) then
         do i = 1,n
            xm1(i,1,1,1) = sx*(xm1(i,1,1,1)-xmin)/(xmax-xmin)-2.5
            ym1(i,1,1,1) = sy*(ym1(i,1,1,1)-ymin)/(ymax-ymin)-2.5
            zm1(i,1,1,1) = sz*(zm1(i,1,1,1)-zmin)/(zmax-zmin)-2.5
         enddo
      else
         do i = 1,n
            xm1(i,1,1,1) = sx*(xm1(i,1,1,1)-xmin)/(xmax-xmin)-2.5
            ym1(i,1,1,1) = sy*(ym1(i,1,1,1)-ymin)/(ymax-ymin)-2.5
         enddo
      endif

c     Mark the regions
      nxy2 = nx1/2
      do e = 1,nelv
         xmid = xm1(nxy2,nxy2,1,e)
         ymid = ym1(nxy2,nxy2,1,e)
         zmid = zm1(nxy2,nxy2,1,e)

         if (ymid.gt.0) then
c     Upper region
            if_in_region(e) = 1
         else
c     Lower region
            if_in_region(e) = 2
         endif
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userfmarker
c-----------------------------------------------------------------------
c     In this routine the user should mark faces that will either need
c     the incident field added to them or have 2D materials on them.
c     Markers for the incident field should be put into the array
c     `fincmarker`; a value of 0 means that no incident field needs to
c     be added and a value of 1 means that the incident field needs to
c     be added. Markers for 2D materials should be mput into the array
c     `f2dmarker`; the currently available values are
c
c     0 -> no 2D material
c     1 -> graphene
c
c     The arrays `fincmarker` and `f2dmarker` are initialized to 0, so
c     if there is no incident field and there are no 2D materials then
c     this subroutine can be left blank.
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'GEOMBOUND'

      logical markinc,mark2d
      integer e,f,i,j,k,nx1_2

      nx1_2 = nx1/2
      do e = 1,nelt
c     *****
c     First mark the faces where the incident field needs to be added
c     *****
         if (ym1(nx1_2,nx1_2,1,e).gt.0.0) then
            markinc = .true.
            do f = 1,nfaces
               do i = 1,nxzf
c     j is the global face number
                  j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
c     k is the volume global number associated with face j.
                  k = cemface(j)
                  if (abs(ym1(k,1,1,1)).gt.1e-8) then
                     markinc = .false.
                     exit
                  endif
               enddo
               if (markinc) then
                  do i = 1,nxzf
                     j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
                     fincmarker(j) = 1
                  enddo
               endif
            enddo
         endif
c     *****
c     Now mark the faces where there are 2d materials
c     *****
         do f = 1,nfaces
            mark2d = .true.
            do i = 1,nxzf
               j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
               k = cemface(j)
               if (abs(ym1(k,1,1,1)).gt.1e-8) then
                  mark2d = .false.
               endif
            enddo
            if (mark2d) then
               do i = 1,nxzf
                  j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
                  f2dmarker(j) = 1
               enddo
            endif
         enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userft
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'PML'

      common /ccpu/ cpu_t,cpu_dtime,cpu_chk

      integer e,ie,i,j
      integer nels,nnn,npt1,npts3,nrsf,ntott,nsrf
      real snel
      real cpu_t,cpu_dtime,cpu_chk,cpu_p_t
      real HXmr,HYmr,HZmr,EXmr,EYmr,EZmr
      real HXer,HYer,HZer,EXer,EYer,EZer
      real glamax,glsc3,glsum

c     Compute errors
      if (istep.le.10.or.mod(istep,iocomm).eq.0) then
         ntott = nx1*ny1*nz1*nelt
         npts3 = nx1*ny1*nz1*nelt*3
         nsrf  = nx1*nz1*nelt*6

         if (ifsol) then
            call usersol(time,sHN(1,1),sHN(1,2),sHN(1,3),
     $           sEN(1,1),sEN(1,2),sEN(1,3))
         else
            call rzero(sHN, npts3) 
            call rzero(sEN, npts3) 
         endif

         call sub3(ErrHN(1,1),SHN(1,1),HN(1,1),NTOTT)
         call sub3(ErrHN(1,2),SHN(1,2),HN(1,2),NTOTT)
         call sub3(ErrHN(1,3),SHN(1,3),HN(1,3),NTOTT)
         call sub3(ErrEN(1,1),SEN(1,1),EN(1,1),NTOTT)
         call sub3(ErrEN(1,2),SEN(1,2),EN(1,2),NTOTT)
         call sub3(ErrEN(1,3),SEN(1,3),EN(1,3),NTOTT)
c     Nuke the components of the error in the PML since we don't expect
c     the computed solution to match the exact solution there
         nxyz = nx1*ny1*nz1
         do e = 1,maxpml
            ie = pmlptr(e)
            do i = 1,nxyz
               j = i+nxyz*(ie-1)
               ErrHN(j,1) = 0.0
               ErrHN(j,2) = 0.0
               ErrHN(j,3) = 0.0
               ErrEN(j,1) = 0.0
               ErrEN(j,2) = 0.0
               ErrEN(j,3) = 0.0
            enddo
         enddo

         HXmr = glamax(ErrHN(1,1),NTOTT)
         HYmr = glamax(ErrHN(1,2),NTOTT)
         HZmr = glamax(ErrHN(1,3),NTOTT)
         EXmr = glamax(ErrEN(1,1),NTOTT)
         EYmr = glamax(ErrEN(1,2),NTOTT)
         EZmr = glamax(ErrEN(1,3),NTOTT)
 
         HXer = glsc3(ErrHN(1,1),bm1,ErrHN(1,1),NTOTT)/ volvm1
         HYer = glsc3(ErrHN(1,2),bm1,ErrHN(1,2),NTOTT)/ volvm1
         HZer = glsc3(ErrHN(1,3),bm1,ErrHN(1,3),NTOTT)/ volvm1
         EXer = glsc3(ErrEN(1,1),bm1,ErrEN(1,1),NTOTT)/ volvm1
         EYer = glsc3(ErrEN(1,2),bm1,ErrEN(1,2),NTOTT)/ volvm1
         EZer = glsc3(ErrEN(1,3),bm1,ErrEN(1,3),NTOTT)/ volvm1

         if (hxer.gt.0) hxer = sqrt(hxer)
         if (hyer.gt.0) hyer = sqrt(hyer)
         if (hzer.gt.0) hzer = sqrt(hzer)
         if (exer.gt.0) exer = sqrt(exer)
         if (eyer.gt.0) eyer = sqrt(eyer)
         if (ezer.gt.0) ezer = sqrt(ezer)

         snel = nelt + .5
         snel = sqrt(snel)
         nels = snel
         nnn  = nx1-1
         npt1 = nnn*nels
c     Note that npts = npt1**ndim
         npts = nx1*ny1*nz1*nelt

         if (istep.eq.0) cpu_p_t = 0
         if (istep.gt.0) cpu_p_t = cpu_t/(npts*istep)
         if (istep.eq.nsteps) cpu_p_t = glsum(cpu_p_t,1)/np

         if (nid.eq.0) then
            if (istep.eq.1) write(6,90)
            write(6,91) ISTEP,nelt,nels,nnn,npt1,npts ,time,dt,HXer,HYer
     $           ,HZer,EXer,EYer,EZer,cpu_t,cpu_p_t
            write(6,95) ISTEP,nelt,nels,nnn,npt1,npts ,time,dt,HXmr,HYmr
     $           ,HZmr,EXmr,EYmr,EZmr,cpu_t,cpu_p_t
 90         format(/,'    istep   nelt  nels  N  npt1    npts   time
     $  dt     HXerr     HYerr     HZerr     EXerr     EYerr     EZerr
     $  cpu_t   cpu_t_pts')
 91         format(/,i10,3i5,i5,i9,1p9e10.3,e9.2,' CPU: L2  '  )
 95         format(  i10,3i5,i5,i9,1p9e10.3,e9.2,' CPU: Linf'  )
         endif
      endif

      return
      end
c-----------------------------------------------------------------------
