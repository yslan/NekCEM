#!/usr/bin/env python
from __future__ import division, print_function, absolute_import

import os
import sys
# Use the old optparse module so that everything works on Python 2.6
import optparse
import multiprocessing
import subprocess
import fileinput
import json

BINDIR = os.path.dirname(os.path.realpath(__file__))
NEKDIR = os.path.abspath(os.path.join(BINDIR, '..'))


class HideCursor():
    """Hide the cursor upon entering and restore it upon exit."""
    def __init__(self):
        pass

    def __enter__(self):
        print('\033[?25l', end='')

    def __exit__(self, exc_type, exc_val, exc_tb):
        print('\033[?25h', end='')


class Directory():
    """Temporarily change the directory."""
    def __init__(self, directory):
        self.new_directory = directory
        self.old_directory = os.getcwd()

    def __enter__(self):
        os.chdir(self.new_directory)

    def __exit__(self, exc_type, exc_val, exc_tb):
        os.chdir(self.old_directory)


class ReaState():
    """Change an `.rea` file upon entering and restore it upon exit."""
    def __init__(self, name, params):
        self.rea = name + '.rea'
        self.params = params
        self.old_params = {}
        self.offset = 4

    def __enter__(self):
        for i, line in enumerate(fileinput.input(self.rea, inplace=True)):
            try:
                print('  {}'.format(self.params[i-self.offset+1]))
                self.old_params[i] = line
            except KeyError:
                print(line, end='')

    def __exit__(self, exc_type, exc_val, exc_tb):
        for i, line in enumerate(fileinput.input(self.rea, inplace=True)):
            try:
                print(self.old_params[i], end='')
            except KeyError:
                print(line, end='')


def tail(fname, n=20):
    """Get the tail of a file. Naive implementation."""
    with open(fname, 'r') as f:
        lines = f.readlines()
    msg = ''.join(lines[-n:])
    return msg


def divider(s):
    """Print a fancy dividing line."""
    w = int(subprocess.check_output(['stty', 'size']).split()[1])
    s = ' ' + s + ' '
    pad = w - len(s)
    halfpad = pad//2
    if pad % 2 == 0:
        line = '='*halfpad + s + '='*halfpad
    else:
        line = '='*halfpad + s + '='*(halfpad + 1)
    return pretty(line, bold=True)


def pretty(s, bold=False, color=None):
    """Use ANSI escape sequences to make print statements pretty."""
    if bold:
        s = '\033[1m' + s + '\033[0m'
    if color == 'green':
        s = '\033[92m' + s + '\033[0m'
    elif color == 'red':
        s = '\033[91m' + s + '\033[0m'
    return s


def build_test(app, directory, usr, np, clean, config):
    with Directory(directory):
        if config or not os.path.isfile('Makefile'):
            config = os.path.join(BINDIR, 'configurenek')
            subprocess.call([config, app, usr])
        if clean:
            subprocess.call(['make', 'clean'])
        arg = '-j{0}'.format(np)
        with open('compiler.out', 'w') as log:
            rc = subprocess.call(['make', arg], stdout=log, stderr=log)
        if rc:
            msg = 'Build failed:\n' + tail('compiler.out')
        else:
            msg = ''
    return msg


def run_test(directory, rea, params, np):
    with Directory(directory):
        nek = os.path.join(BINDIR, 'nek')
        cmd = [nek, rea, np]
        with ReaState(rea, params):
            with open(os.devnull, 'w') as null:
                rc = subprocess.call(cmd, stdout=null, stderr=null)
        if rc:
            log = '{0}.np={1}.output'.format(rea, np)
            msg = 'Run failed:\n' + tail(log)
        else:
            msg = ''
    return msg


def main():
    parser = optparse.OptionParser()
    parser.add_option('--collect-only',
                      help=('list the names of the tests, but do not'
                            ' run them'),
                      action='store_true')
    parser.add_option('-p', '--pattern',
                      help=('only run tests whose names contain'
                            ' the given substring'))
    parser.add_option('--np',
                      help=('how many processors to run with'))
    parser.add_option('--clean', action="store_true",
                      help=('whether to clean before building;'
                            ' default is False'))
    parser.add_option('--config', action='store_true',
                      help=('whether to run nekconfigure; default is'
                            ' true'))
    parser.add_option('--build-only', action='store_true',
                      help=('build the test but do not run it'))
    options, args = parser.parse_args()
    if args:
        raise ValueError(("there shouldn't be any positional"
                          " arguments"))
    if options.pattern:
        pattern = options.pattern
    else:
        pattern = ''
    if options.np:
        np = options.np
    else:
        # Multiprocessing counts the number of logical processors. We
        # want the number of physical processors so we divide by 2.
        np = str(multiprocessing.cpu_count()//2)
    clean = options.clean
    config = options.config

    testdata = {}
    pwd = os.getcwd()
    for group in os.walk(pwd):
        if 'tests.json' in group[2]:
            tests = os.path.join(group[0], 'tests.json')
            with open(tests, 'r') as json_data:
                data = json.load(json_data)
                for key in data:
                    directory = os.path.join(group[0], data[key]['dir'])
                    data[key]['dir'] = directory
                testdata.update(data)
    if options.collect_only:
        for key in testdata:
            print(key)
        sys.exit(0)

    with HideCursor():
        msg = 'Running the tests with np = {0}'.format(np)
        print(pretty(msg, bold=True))
        total = 0
        fails = []
        for key in sorted(testdata.keys()):
            if pattern not in key:
                continue
            print(key, end='')
            sys.stdout.flush()
            app = testdata[key]['app']
            directory = testdata[key]['dir']
            usr = testdata[key]['usr']
            rea = testdata[key]['rea']
            params = testdata[key]['params']
            params = {int(k): v for k, v in params.items()}
            msg = build_test(app, directory, usr, np, clean, config)
            if not options.build_only and not msg:
                msg = run_test(directory, rea, params, np)
            if not msg:
                print('\r' + key + pretty(' PASSED', color='green'))
            else:
                print('\r' + key + pretty(' FAILED', color='red'))
                fails.append((key, msg))
            total += 1
        for key, msg in fails:
            print(divider(key))
            print(msg)
        msg = "{0} tests run; {1} successes; {2} failures"
        msg = msg.format(total, total - len(fails), len(fails))
        print(pretty(msg, bold=True))

    if fails:
        sys.exit(1)
    else:
        sys.exit(0)


if __name__ == '__main__':
    main()
