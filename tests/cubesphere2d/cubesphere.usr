c-----------------------------------------------------------------------
c
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine userinc
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt,mycn)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'DRIFT'
      include 'CUBESPHERE' ! check surface area
      real xx
      real mycn(lx1*ly1*lz1*lelt,lcdim) ! cN

      integer i
      real alpha,beta
      real ex_po,ex_cn,ex_cp,in_turb 

      real cn_xm,cn_xp,cn_ym,cn_yp !   y
      real cp_xm,cp_xp,cp_ym,cp_yp !  p4 --- p3
      real cn_p1,cn_p2,cn_p3,cn_p4 !   |     |
      real cp_p1,cp_p2,cp_p3,cp_p4 !  p1 --- p2 -> x
      real surf_area, glsum

      alpha = 1.0
      beta  = 1.0

      cn_p1 = exp(1.5 - 1.0)
      cn_p2 = exp(1.5 - 1.0)
      cn_p3 = exp(1.5 - 1.0)
      cn_p4 = exp(1.5 - 1.0)
      cp_p1 = exp(2.0 + 1.0)
      cp_p2 = exp(2.0 + 1.0)
      cp_p3 = exp(2.0 + 1.0)
      cp_p4 = exp(2.0 + 1.0)

      do i = 1,npts
        xx = xm1(i,1,1,1)
        yy = ym1(i,1,1,1)
c        in_turb = 2.0*( sin(20*pi*xx) + cos(20*pi*yy) )
c
c        ex_po = sin(alpha*pi*xx) + cos(beta*pi*yy)
c        ex_cn = exp(1.5+ex_po) ! ex sol for cn
c        ex_cp = exp(2.0-ex_po) ! ex sol for cp
c
c        cn_xm = exp(1.5 + cos(beta*pi*yy)) 
c        cn_xp = exp(1.5 + cos(beta*pi*yy)) 
c        cn_ym = exp(1.5 + sin(alpha*pi*xx)-1.0) 
c        cn_yp = exp(1.5 + sin(alpha*pi*xx)-1.0) 
c
c        cp_xm = exp(2.0 - cos(beta*pi*yy)) 
c        cp_xp = exp(2.0 - cos(beta*pi*yy)) 
c        cp_ym = exp(2.0 - sin(beta*pi*xx)+1.0) 
c        cp_yp = exp(2.0 - sin(beta*pi*xx)+1.0) 
c
c
cC       Transfinite Mapping by boundary values
cc        mycn(i,1) = 0.5*(xx+1.0)*cn_xm + 0.5*(1.0-xx)*cn_xp
cc     $            + 0.5*(yy+1.0)*cn_ym + 0.5*(1.0-yy)*cn_yp
cc     $            - cn_p1
cc        mycn(i,2) = 0.5*(xx+1.0)*cp_xm + 0.5*(1.0-xx)*cp_xp
cc     $            + 0.5*(yy+1.0)*cp_ym + 0.5*(1.0-yy)*cp_yp
cc     $            - cp_p1


        mycn(i,1) = 1.0  !ex_cn  ! + in_turb
        mycn(i,2) = 1.0  !exp(2.0)  !ex_cp  ! + in_turb
      enddo

      surf_area = glsum(bmn,npts)
      if(nid.eq.0) write(*,*) 'Lan>> surf_area in init',surf_area

      return
      end
c-----------------------------------------------------------------------
      subroutine usersol(tt,myscn1,myscn2,myscn3,myscn4,myscn5,myscn6)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'DRIFT'
      include 'POISSON'
      include 'CUBESPHERE'

      common /my_output/ div_out (lx1*ly1*lz1*lelt)
     $               ,   div_out1(lx1*ly1*lz1*lelt)
     $               ,   div_out2(lx1*ly1*lz1*lelt)
     $               ,   CS_w1   (lx1*ly1*lz1*lelt)
     $               ,   CS_w2   (lx1*ly1*lz1*lelt)
     $               ,   CS2_w1  (lx1*ly1*lz1*lelt)
     $               ,   CS2_w2  (lx1*ly1*lz1*lelt)
     $               ,   ex_div (lx1*ly1*lz1*lelt)
      real div_out,div_out1,CS_w1,CS_w2
      real div_out2,CS2_w1,CS2_w2,ex_div
      real tt,tot_cN
      real tmp(lx1*ly1*lz1*lelt)
      real myscn1(lx1*ly1*lz1*lelt) !potent
      real myscn2(lx1*ly1*lz1*lelt,lcdim) !cN
      real myscn3(lx1*ly1*lz1*lelt)
      real myscn4(lx1*ly1*lz1*lelt)
      real myscn5(lx1*ly1*lz1*lelt)
      real myscn6(lx1*ly1*lz1*lelt)


      integer i,j,ie
      real xx, yy

      real alpha,beta
      real ex_po,ex_cn,ex_cp,in_turb 
      real glsum

      alpha = 1.0
      beta  = 1.0

      npts = nx1*ny1*nz1*nelt
      do i = 1,npts
        xx = xm1(i,1,1,1)
        yy = ym1(i,1,1,1)
        in_turb = 2.0*( sin(20*pi*xx) + cos(20*pi*yy) )

        ex_po = sin(alpha*pi*xx) + cos(beta*pi*yy)
        ex_cn = exp(1.5+ex_po) ! ex sol for cn
        ex_cp = exp(2.0-ex_po) ! ex sol for cp

c        myscn2(i,1) = charge(i)  !ex_cn
c        myscn2(i,2) = ex_cp
c        myscn2(i,1) = EqAngAlpha(i,1,1,1)  !ex_cn
c        myscn2(i,2) = EqAngBeta (i,1,1,1)
c        myscn2(i,1) = CubeSphX(i,1,1,1)  !ex_cn
c        myscn2(i,2) = CubeSphY(i,1,1,1)
c        myscn1(i)   = CubeSphZ(i,1,1,1)
c        cn(i,1) = 
c        myscn1(i)   = ex_po ! ex sol for phi  
         xx = ((CubeSphX(i,1,1,1)-BigR)**2
     $        +CubeSphY(i,1,1,1)**2
     $        +CubeSphZ(i,1,1,1)**2)/0.25
c         myscn2(i,1) = CS_Jac(i,1,1,1)
c         myscn2(i,1) = CS_u1(i)
c         myscn2(i,2) = CS_u2(i)
c         myscn2(i,1) = CS_A_22(i)
c         myscn2(i,2) = CS_A_12(i)
c         myscn2(i,1) = V_long(i)
c         myscn2(i,2) = V_lati(i)
c         myscn2(i,2) = Vabs(i)
c         myscn1(i)   = jacm(i)
         myscn2(i,1)   = ex_div(i)
         myscn2(i,2) = div_out2(i)
c         myscn1(i) = div_out(i)
c         myscn2(i,1) = CS_V_X(i)
c         myscn2(i,2) = CS_V_Y(i)
c         myscn1(i)   = CS_V_Z(i)
c         myscn2(i,1) = CS_w1(i)
c         myscn2(i,2) = CS_w2(i)
      enddo

c      do ie = 1,nelt ! check face id
c        do j = 1,nxyz
c          i = j + nxyz*(ie-1)
c          myscn2(i,2) = if_in_region(ie)
c          myscn1(i) = ie
c        enddo
c      enddo
      call col3(tmp,bmn,cN(1,1),npts)
      tot_cN = glsum(tmp,npts)
      if (nid.eq.0) write(*,*)'Lan total cN, t,total',tt,tot_cN

      return
      end
c-----------------------------------------------------------------------
      subroutine usersrc(tt,rhs_phi,rhs_cn,dummy1,dummy2,dummy3,dummy4)     
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'DRIFT'
      include 'POISSON'
      include 'BCS'

      integer i,j,i0,ic 
      real    tt, xx,yy
      real    rhs_cn(lpts1,lcdim)
      real    rhs_phi(1), dummy1(1),dummy2(1)
      real    dummy3(1),dummy4(1)
      real    zmax,zmin,glmax,glmin
      real    eps, tmp2, tmp3 ! for constructing exact sol.
      real    alpha,beta
      real    ex_po,ex_cn,ex_cp
      real    cnp_max ! estimating in STERIC

      alpha = 1.0
      beta  = 1.0
      eps = 1.e-14
      
      call rzero(rhs_cN(1,1),npts)
      call rzero(rhs_cN(1,2),npts)

      call rzero(rhs_phi,npts)
      do ic = 1,lcdim
        call add2s2(rhs_phi,cN(1,ic),zvalence(ic),npts)
      enddo
      call add2s2(rhs_phi,charge,1.0,npts)
      call col2(rhs_phi,bmn,npts)

C     shouldn't have any BCs
C      if (ncemface_pec(2).ge.1)  then ! second field  cn 
C
C         do i=1,ncemface_pec(2)
C            j = cemface_pec(i,2)
C            i0 = cemface(j)
C            xx = xm1(i0,1,1,1)
C            yy = ym1(i0,1,1,1)
C
C            ex_po = sin(alpha*pi*xx) + cos(beta*pi*yy)
C            ex_cn = exp(1.5+ex_po) ! ex sol for cn
C
C            cN(i0,1) = ex_cn
C         enddo
C      endif
C
C      if (ncemface_pec(3).ge.1)  then ! third field cp
C
C         do i=1,ncemface_pec(3)
C            j = cemface_pec(i,3) 
C            i0 = cemface(j)      
C            xx = xm1(i0,1,1,1)
C            yy = ym1(i0,1,1,1)
C
C            ex_po = sin(alpha*pi*xx) + cos(beta*pi*yy)
C            ex_cp = exp(2.0-ex_po) ! ex sol for cp
C         
C            cN(i0,2) = ex_cp
C         enddo
C
C      endif
C
C
Cc.....source for potential field (phi) at time
C      call rzero(rhs_phi,npts)
C      do ic = 1,lcdim
C        call add2s2(rhs_phi,cN(1,ic),zvalence(ic),npts)
C      enddo
C      call add2s2(rhs_phi,charge,1.0,npts)
C      call col2(rhs_phi,bmn,npts)
Cc.....scale_potent has to be fixed 
C
C      if (ncemface_pec(1).gt.0) then
C        do i = 1,ncemface_pec(1)
C          j = cemface_pec(i,1) 
C          i0 = cemface(j)               ! surface index to volume index
C          xx = xm1(i0,1,1,1)
C          yy = ym1(i0,1,1,1)
C
C          ex_po = sin(alpha*pi*xx) + cos(beta*pi*yy)
C
C          potent(i0) = ex_po
C        enddo
C      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,iel)
c---------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'DRIFT'
      include 'POISSON'
      include 'CUBESPHERE'

      parameter(lt=lx1*ly1*lz1*lelt)
      common /myfields/ perm(lt),diff(lt),distp(lt),psrc(lt)
     $                , phip(lt),phix(lt),phiy(lt),phiz(lt)

      integer i,j,k,l,ie,ieg
      real tmp, D_n_max, D_p_max
      real tmp2, tmp3, alpha, beta
      real ex_po, ex_cn, ex_cp, ex_ddpo
      real xx,yy,rr


c     vvvvvv Cubed Sphere Basics
      call construct_cubespheregrid ! Lan, cube


      zvalence(1) = -1.0 ! cN
      zvalence(2) =  1.0 ! cP

      D_n_max = 1.0
      D_p_max = 1.0

      alpha = 1.0
      beta  = 1.0
      
      do i= 1,npts 
         d_permit(i)=  1.0  ! not used
         d_permea(i)=  1.0  ! not used

         mu_n  (i,1)=  1.0  ! D_n_max 
         mu_n  (i,2)=  1.0  ! D_p_max  

         xx = xm1(i,1,1,1)
         yy = ym1(i,1,1,1)

         ex_po = sin(alpha*pi*xx) + cos(beta*pi*yy)
         ex_cn = exp(1.5+ex_po) ! ex sol for cn
         ex_cp = exp(2.0-ex_po) ! ex sol for cp

         ex_ddpo= -1.0*(  alpha**2*pi**2*sin(alpha*pi*xx)
     $                  + beta**2 *pi**2*cos(beta*pi*yy)  )
         tmp2 = -1.0 * ex_cn
         tmp3 =  1.0 * ex_cp ! negative valence
         
         charge(i) = 0.0
c         if (xx.lt.2.0.AND.xx.gt.1.0) then ! element 3
c         if (yy.lt.2.0.AND.yy.gt.1.0) then
           rr = (xx-1.8)**2+(yy-1.8)**2
           if (rr.lt.0.25) then             
             charge(i)= -1.0
           endif
c         endif
c         endif
      enddo

      do ic = 1,lcdim
        call copy(diff_n(1,ic),mu_n(1,ic),npts)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'

C     Todo: adjuct jacobian and comment out the check(?), Lan

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'

      real rscale
      real xmin,ymin,zmin,xmax,ymax,zmax


c     Rescale Mesh: first face from [0,1] to [-pi/4,pi/4]

      xmin = glmin(xm1,npts)
      xmax = glmax(xm1,npts)
      ymin = glmin(ym1,npts)
      ymax = glmax(ym1,npts)

      if (nid.eq.0) then
        write(6,11)'Lcheck domain, range of rea (xmin/xmax)',xmin,xmax
        write(6,11)'Lcheck domain, range of rea (ymin/ymax)',ymin,ymax
      endif

      sx = 2.0*pi/(xmax-xmin)
      sy = 1.5*pi/(ymax-ymin)
      do i = 1,npts
         xm1(i,1,1,1) = sx*(xm1(i,1,1,1)-xmin)-pi/4
         ym1(i,1,1,1) = sy*(ym1(i,1,1,1)-ymin)-pi/4
      enddo

      xmin = glmin(xm1,npts)
      xmax = glmax(xm1,npts)
      ymin = glmin(ym1,npts)
      ymax = glmax(ym1,npts)
      if (nid.eq.0) then
        write(6,11)'Lcheck domain, range of EqAngBox (xmin/xmax)'
     $             ,xmin,xmax
        write(6,11)'Lcheck domain, range of EqAngBox (ymin/ymax)'
     $             ,ymin,ymax
      endif

   11 format(A,2f14.8)

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'DRIFT'
      include 'POISSON'
      include 'RTIMER'

      integer i
      real l2(6),linf(6)
      real l2tol(6),linftol(6)
      real dummy(lx1*ly1*lz1*lelt)

      l2(1) = 0.0
      l2(2) = 0.0
      l2(3) = 0.0
      l2(4) = 0.0
      l2(5) = 0.0
      l2(6) = 0.0

      linf(1) = 0.0
      linf(2) = 0.0
      linf(3) = 0.0
      linf(4) = 0.0
      linf(5) = 0.0
      linf(6) = 0.0

      l2tol(1) = 2e-6
      l2tol(2) = 3e-6
      l2tol(3) = 0.0
      l2tol(4) = 8e-8
      l2tol(5) = 0.0
      l2tol(6) = 0.0

      linftol(1) = 5e-6
      linftol(2) = 7e-6
      linftol(3) = 0.0
      linftol(4) = 2e-7
      linftol(5) = 0.0
      linftol(6) = 0.0

      if (istep.le.10.or.mod(istep,iocomm).eq.0) then
         call usersol(time,spotent,scn,dummy,dummy,dummy,dummy)

         call cem_error(cN(1,1),scN(1,1),errcN(1,1),npts,l2(1),linf(1))
         call cem_error(cN(1,2),scN(1,2),errcN(1,2),npts,l2(2),linf(2))
         call cem_error(potent,spotent,epotent,npts,l2(4),linf(4))

         call userprint(istep,time,dt,l2,linf,cpu_t,cpu_p_t)

        if (istep.eq.nsteps) then
           do i = 1,6
              if (l2(i).gt.l2tol(i)) call exitt(1)
              if (linf(i).gt.linftol(i)) call exitt(1)
           enddo
        endif
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userprint(istep,tt,dt,l2,linf,t1,t2)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      integer istep
      real tt,dt,t1,t2
      real l2(6),linf(6)

      integer k

      if (nid.eq.0) then
         write(6,101) istep,nelt,nx1-1,npts,tt,dt,(l2(k),k=1,6),t1,t2
         write(6,102) istep,nelt,nx1-1,npts,tt,dt,(linf(k),k=1,6),t1,t2
      endif

 101  format(/,i10,i6,i4,i9,1p9e10.3,e9.2,' CPU: L2')
 102  format(  i10,i6,i4,i9,1p9e10.3,e9.2,' CPU: Linf')

      return
      end
c-----------------------------------------------------------------------
      subroutine construct_cubespheregrid
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'POISSON'
      include 'DRIFT'
      include 'CUBESPHERE'

      common /my_output/ div_out (lx1*ly1*lz1*lelt)
     $               ,   div_out1(lx1*ly1*lz1*lelt)
     $               ,   div_out2(lx1*ly1*lz1*lelt)
     $               ,   CS_w1   (lx1*ly1*lz1*lelt)
     $               ,   CS_w2   (lx1*ly1*lz1*lelt)
     $               ,   CS2_w1  (lx1*ly1*lz1*lelt)
     $               ,   CS2_w2  (lx1*ly1*lz1*lelt)
     $               ,   ex_div (lx1*ly1*lz1*lelt)
   
      integer i,j,k,l,ie,ieg
      integer mx,my,mz
      integer ierr,NEL,iglsum
      real rscale,ex_div
      real xmin,ymin,zmin,xmax,ymax,zmax
      real xx,yy,zz,rr
      real FaceNum, xshift, yshift
      real glsum,glmax,glmin,glamax
      real tmp_dsdx(4)
      real CS_Jacdx
      real surf_area
      real tmp  (lx1*ly1*lz1*lelt)
      real tmp_f(lx1*ly1*lz1*lelt)
      real div_out,div_out1,CS_w1,CS_w2
      real div_out2,CS2_w1,CS2_w2
     $   , CS_u1vec(lx1*ly1*lz1*lelt)
     $   , CS_u2vec(lx1*ly1*lz1*lelt)
     $   , tmp_v   (lx1*ly1*lz1*lelt)
     $   , test_long(lx1*ly1*lz1*lelt)
     $   , test_lati(lx1*ly1*lz1*lelt)
     $   , test_u1(lx1*ly1*lz1*lelt)
     $   , test_u2(lx1*ly1*lz1*lelt)
     $   , tmp_div(lx1*ly1*lz1*lelt)
      real amax_w1,amax_w2,amax_div
      real amax2_w1,amax2_w2,amax2_div
      real tmp_result
      real tmp_result2
      real tmpc1,tmpc2
      real eps

      real NpoleX,NpoleY,NpoleZ
      real SpoleX,SpoleY,SpoleZ
      real tt_dist1,tt_dist2

C     LLLLLLLLL

      nxyz = nx1*ny1*nz1
      npts = nxyz*nelt

C     Determine face id
      do ie = 1,nelt
        xx = (xm1(1,1,1,ie)+xm1(nx1,ny1,1,ie))*0.5
        yy = (ym1(1,1,1,ie)+ym1(nx1,ny1,1,ie))*0.5
        if_in_region(ie) = 0

        if (xx.gt.(-0.25*pi).AND.xx.lt.(0.25*pi)) then
          if (yy.gt.(-0.25*pi).AND.yy.lt.(0.25*pi)) then
            if_in_region(ie) = 1
          else
            write(*,*)'Lan, if_in_region err,nid,ie,xx,yy',nid,ie,xx,yy
          endif
        elseif (xx.lt.(0.75*pi)) then
          if (yy.gt.(-0.25*pi).AND.yy.lt.(0.25*pi)) then
            if_in_region(ie) = 2
          elseif (yy.gt.(0.25*pi).AND.yy.lt.(0.75*pi)) then
            if_in_region(ie) = 3
          else
            write(*,*)'Lan, if_in_region err,nid,ie,xx,yy',nid,ie,xx,yy
          endif
        elseif (xx.lt.(1.25*pi)) then
          if (yy.gt.(0.25*pi).AND.yy.lt.(0.75*pi)) then
            if_in_region(ie) = 4
          elseif (yy.gt.(0.75*pi).AND.yy.lt.(1.25*pi)) then
            if_in_region(ie) = 5
          else
            write(*,*)'Lan, if_in_region err,nid,ie,xx,yy',nid,ie,xx,yy
          endif
        elseif (xx.lt.(1.75*pi)) then
          if (yy.gt.(0.75*pi).AND.yy.lt.(1.25*pi)) then
            if_in_region(ie) = 6
          else
            write(*,*)'Lan, if_in_region err,nid,ie,xx,yy',nid,ie,xx,yy
          endif
        else
          write(*,*)'Lan, if_in_region err,nid,ie,xx,yy',nid,ie,xx,yy
        endif
      enddo

c     compute equal angular alpha and beta
      do ie = 1,nelt
        if (if_in_region(ie).eq.1) then  ! face 1
          xshift = 0.0
          yshift = 0.0
        elseif (if_in_region(ie).eq.2) then ! face 2
          xshift = 0.5*pi
          yshift = 0.0
        elseif (if_in_region(ie).eq.3) then ! face 3
          xshift = 0.5*pi
          yshift = 0.5*pi
        elseif (if_in_region(ie).eq.4) then ! face 4
          xshift = pi
          yshift = 0.5*pi
        elseif (if_in_region(ie).eq.5) then ! face 5
          xshift = pi
          yshift = pi
        elseif (if_in_region(ie).eq.6) then ! face 6
          xshift = 1.5*pi
          yshift = pi
        else
          if(nid.eq.0)write(*,*)'Lan, error in if_in_region2'
     $                        ,if_in_region(ie)
        endif

        do j = 1,nxyz
          i = j + (ie-1)*nxyz
          EqAngAlpha(i,1,1,1) = xm1(i,1,1,1) - xshift
          EqAngBeta (i,1,1,1) = ym1(i,1,1,1) - yshift
        enddo
      enddo

c     compute spherical coordinate
      BigR = param(3) ! Lan, tmp, radius of sphere
      CubeLength = BigR/sqrt(3.0)
      if (nid.eq.0) write(6,*)'Lcheck SphR = ',BigR
      if (nid.eq.0) write(6,*)'Lcheck CubeLength = ',CubeLength

      do ie = 1,nelt
        if (if_in_region(ie).eq.1) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            CS_xtmp = CubeLength * tan(EqAngAlpha(i,1,1,1))
            CS_ytmp = CubeLength * tan(EqAngBeta (i,1,1,1))
            CS_rtmp = sqrt(
     $                CubeLength**2 + CS_xtmp**2 + CS_ytmp**2)
            CubeSphX(i,1,1,1) =  BigR * CubeLength / CS_rtmp
            CubeSphY(i,1,1,1) =  BigR * CS_xtmp / CS_rtmp
            CubeSphZ(i,1,1,1) =  BigR * CS_ytmp / CS_rtmp
          enddo
        elseif (if_in_region(ie).eq.2) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            CS_xtmp = CubeLength * tan(EqAngAlpha(i,1,1,1))
            CS_ytmp = CubeLength * tan(EqAngBeta (i,1,1,1))
            CS_rtmp = sqrt(
     $                CubeLength**2 + CS_xtmp**2 + CS_ytmp**2)
            CubeSphX(i,1,1,1) = -BigR * CS_xtmp / CS_rtmp
            CubeSphY(i,1,1,1) =  BigR * CubeLength / CS_rtmp
            CubeSphZ(i,1,1,1) =  BigR * CS_ytmp / CS_rtmp
          enddo
        elseif (if_in_region(ie).eq.3) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            CS_xtmp = CubeLength * tan(EqAngAlpha(i,1,1,1))
            CS_ytmp = CubeLength * tan(EqAngBeta (i,1,1,1))
            CS_rtmp = sqrt(
     $                CubeLength**2 + CS_xtmp**2 + CS_ytmp**2)
            CubeSphX(i,1,1,1) = -BigR * CS_xtmp / CS_rtmp
            CubeSphY(i,1,1,1) = -BigR * CS_ytmp / CS_rtmp
            CubeSphZ(i,1,1,1) =  BigR * CubeLength / CS_rtmp
          enddo
        elseif (if_in_region(ie).eq.4) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            CS_xtmp = CubeLength * tan(EqAngAlpha(i,1,1,1))
            CS_ytmp = CubeLength * tan(EqAngBeta (i,1,1,1))
            CS_rtmp = sqrt(
     $                CubeLength**2 + CS_xtmp**2 + CS_ytmp**2)
            CubeSphX(i,1,1,1) = -BigR * CubeLength / CS_rtmp
            CubeSphY(i,1,1,1) = -BigR * CS_ytmp / CS_rtmp
            CubeSphZ(i,1,1,1) = -BigR * CS_xtmp / CS_rtmp
          enddo
        elseif (if_in_region(ie).eq.5) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            CS_xtmp = CubeLength * tan(EqAngAlpha(i,1,1,1))
            CS_ytmp = CubeLength * tan(EqAngBeta (i,1,1,1))
            CS_rtmp = sqrt(
     $                CubeLength**2 + CS_xtmp**2 + CS_ytmp**2)
            CubeSphX(i,1,1,1) =  BigR * CS_ytmp / CS_rtmp
            CubeSphY(i,1,1,1) = -BigR * CubeLength / CS_rtmp
            CubeSphZ(i,1,1,1) = -BigR * CS_xtmp / CS_rtmp
          enddo
        elseif (if_in_region(ie).eq.6) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            CS_xtmp = CubeLength * tan(EqAngAlpha(i,1,1,1))
            CS_ytmp = CubeLength * tan(EqAngBeta (i,1,1,1))
            CS_rtmp = sqrt(
     $                CubeLength**2 + CS_xtmp**2 + CS_ytmp**2)
            CubeSphX(i,1,1,1) =  BigR * CS_ytmp / CS_rtmp
            CubeSphY(i,1,1,1) =  BigR * CS_xtmp / CS_rtmp
            CubeSphZ(i,1,1,1) = -BigR * CubeLength / CS_rtmp
          enddo
        else
          if(nid.eq.0)write(*,*)'Lan, error in if_in_region3'
     $                        ,if_in_region(ie)
        endif
      enddo

      call copy(xm1,CubeSphX,npts)
      call copy(ym1,CubeSphY,npts)
      call copy(zm1,CubeSphZ,npts)
      call copy(xmn,CubeSphX,npts)
      call copy(ymn,CubeSphY,npts)
      call copy(zmn,CubeSphZ,npts)

      eps = 1E-12

c     longitudes and latitudes
      do i = 1,npts
        CubeSphXtmp = CubeSphX(i,1,1,1)
        CubeSphYtmp = CubeSphY(i,1,1,1)
        CubeSphZtmp = CubeSphZ(i,1,1,1)
        long(i) = atan2(CubeSphYtmp, CubeSphXtmp)
        lati(i) = atan2(CubeSphZtmp,
     $     sqrt(CubeSphXtmp**2  + CubeSphYtmp**2))
        sn_long(i) = sin(long(i))
        cs_long(i) = cos(long(i))
        sn_lati(i) = sin(lati(i))
        cs_lati(i) = cos(lati(i))
      enddo


cc     fix north/south pole
c      NpoleZ = glmax(CubeSphZ,npts)
c      SpoleZ = glmin(CubeSphZ,npts)
c      if (nid.eq.0) then
c        write(*,*)'Lan>> (NpoleZ,SpoleZ) =',NpoleZ,SpoleZ
c      endif 
c      do i=1,npts
c        xx = CubeSphX(i,1,1,1)
c        yy = CubeSphY(i,1,1,1)
c        zz = CubeSphZ(i,1,1,1)
c
c        tt_dist1 = abs(zz-NpoleZ)
c        tt_dist2 = abs(zz-SpoleZ)
c
c        if (tt_dist1.lt.1E-6) then 
c          write(*,*)'Lan, find a N-pole',
c     $      '(xx,yy,zz)',xx,yy,zz,'long',long(i)
c        endif
c        if (tt_dist2.lt.1E-6) then
c          write(*,*)'Lan, find a S-pole',
c     $      '(xx,yy,zz)',xx,yy,zz,'long',long(i)
c        endif
c      enddo



c     A matrix
      do ie = 1,nelt
        if ( if_in_region(ie) .eq. 1 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlpha(i,1,1,1)
            arg2 = EqAngBeta (i,1,1,1)
            CS_A_11(i) =  BigR 
     $         * cs_long(i)**2 * cs_lati(i) / cos(arg1)**2
            CS_A_12(i) =  0.0
            CS_A_21(i) = -BigR 
     $         * sn_long(i) * cs_long(i)
     $         * sn_lati(i) * cs_lati(i)    / cos(arg1)**2
            CS_A_22(i) =  BigR 
     $         * cs_long(i) * cs_lati(i)**2 / cos(arg2)**2
          enddo
        elseif ( if_in_region(ie) .eq. 2 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlpha(i,1,1,1)
            arg2 = EqAngBeta (i,1,1,1)
            CS_A_11(i) = BigR 
     $         * sn_long(i)**2 * cs_lati(i) / cos(arg1)**2
            CS_A_12(i) =  0.0
            CS_A_21(i) = BigR 
     $         * sn_long(i) * cs_long(i) 
     $         * sn_lati(i) * cs_lati(i)    / cos(arg1)**2
            CS_A_22(i) = BigR 
     $         * sn_long(i) * cs_lati(i)**2 / cos(arg2)**2
            enddo
        elseif ( if_in_region(ie) .eq. 3 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlpha(i,1,1,1)
            arg2 = EqAngBeta (i,1,1,1)
            CS_A_11(i) =  BigR
     $         * sn_long(i) * sn_lati(i)    / cos(arg1)**2
            CS_A_12(i) = -BigR 
     $         * cs_long(i) * sn_lati(i)    / cos(arg2)**2
            CS_A_21(i) =  BigR 
     $         * cs_long(i) * sn_lati(i)**2 / cos(arg1)**2
            CS_A_22(i) = BigR 
     $         * sn_long(i) * sn_lati(i)**2 / cos(arg2)**2
          enddo
        elseif ( if_in_region(ie) .eq. 4 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlpha(i,1,1,1)
            arg2 = EqAngBeta (i,1,1,1)
            CS_A_11(i) =  0.0
            CS_A_12(i) =  BigR
     $          * cs_long(i)**2* cs_lati(i) / cos(arg2)**2
            CS_A_21(i) = BigR 
     $         * cs_long(i) * cs_lati(i)**2 / cos(arg1)**2
            CS_A_22(i) = -BigR 
     $         * sn_long(i) * cs_long(i)
     $         * sn_lati(i) * cs_lati(i)    / cos(arg2)**2
          enddo
        elseif ( if_in_region(ie) .eq. 5 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlpha(i,1,1,1)
            arg2 = EqAngBeta (i,1,1,1)
            CS_A_11(i) =  0.0
            CS_A_12(i) = BigR 
     $         * sn_long(i)**2 * cs_lati(i) / cos(arg2)**2
            CS_A_21(i) = BigR 
     $         * sn_long(i) * cs_lati(i)**2 / cos(arg1)**2
            CS_A_22(i) = BigR 
     $         * sn_long(i) * cs_long(i)
     $         * sn_lati(i) * cs_lati(i)    / cos(arg2)**2
            enddo
        elseif ( if_in_region(ie) .eq. 6 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlpha(i,1,1,1)
            arg2 = EqAngBeta (i,1,1,1)
            CS_A_11(i) = -BigR
     $         * cs_long(i) * sn_lati(i)    / cos(arg1)**2
            CS_A_12(i) = BigR
     $         * sn_long(i) * sn_lati(i)    / cos(arg2)**2
            CS_A_21(i) = BigR 
     $         * sn_long(i) * sn_lati(i)**2 / cos(arg1)**2
            CS_A_22(i) = BigR 
     $         * cs_long(i) * sn_lati(i)**2 / cos(arg2)**2
          enddo
        endif
      enddo

c     Compute inv(A) and Jacobian
      do i=1,npts   ! compute inv(A)
            CS_Atmp = CS_A_11(i)*CS_A_22(i)
     $              - CS_A_12(i)*CS_A_21(i)
         CS_ainv11(i) =  CS_A_22(i)/CS_Atmp
         CS_ainv12(i) = -CS_A_12(i)/CS_Atmp
         CS_ainv21(i) = -CS_A_21(i)/CS_Atmp
         CS_ainv22(i) =  CS_A_11(i)/CS_Atmp

         CS_Jac(i,1,1,1) = abs(CS_Atmp)
c         CS_Jac(i,1,1,1) = BigR**2 / cos(arg1)**2 / cos(arg2)**2
c     $      / ( 1.0 + tan(arg1)**2 + tan(arg2)**2 )**1.5
      enddo

C     Test and replace d(rst)/d(xyz)
      if(nid.eq.0) write(*,*)'Lan>> chk Jac start'
      do ie=1,nelt
        call CHKJAC(CS_Jac(1,1,1,ie),nxyz,ie,xm1,ym1,zm1,ndim,ierr)
      enddo

      if (nid.eq.0) write(*,*)'Lan>> Jac old: jacm,jacm1'
     $             ,jacm(1),jacm1(1,1,1,1)

      call col2(jacm1,CS_Jac,npts)
      call col2(jacm,CS_Jac,npts)
      call col2(bmn,CS_Jac,npts)
      call copy(bm1,bmn,npts)

      if (nid.eq.0) write(*,*)'Lan>> Jac new: jacm,jacm1'
     $             ,jacm(1),jacm1(1,1,1,1)

c     Check surface area
      surf_area = glsum(bmn,npts)
      if (nid.eq.0) write(*,*)'Lcheck surf area=',surf_area,
     $                        'exact: 4piR=',4.0*pi*BigR**2
c     Check integral: int (x-1)**2 + yy**2 + zz**2 dS = 4*pi*R^2*(R^2+1)
      do i=1,npts
        xx = CubeSphX (i,1,1,1)
        yy = CubeSphY (i,1,1,1)
        zz = CubeSphZ (i,1,1,1)
        tmp_f(i) = (xx-1.0)**2 + yy**2 + zz**2
      enddo
      call col3(tmp,tmp_f,bmn,npts)
      tmp_result = glsum(tmp,npts)
      if (nid.eq.0) then
        write(*,*)'Lcheck>> ==========================================='
        write(*,*)'Lcheck>> [An execise:'
        write(*,*)'Lcheck>> [ int (x-1)**2 + yy**2 + zz**2 dS'
        write(*,*)'Lcheck>> [ the numerical integral is',tmp_result
        write(*,*)'Lcheck>> [   ans:   4*pi*R^2(R^2+1)='
     $            ,4.0*pi*BigR**2*(BigR**2+1.0)
        write(*,*)'Lcheck>> ==========================================='
      endif

C     Test and replace d(rst)/d(xyz), ToDo: replace later by Lan
      nel = iglsum(nelt,1)
      dx1v = (pi/sqrt(nel/6.0))/2.0
      CS_Jacdx = dx1v/2
      tmp_dsdx(1) = glmax(rxm1,npts)
      tmp_dsdx(2) = glmax(rym1,npts)
      tmp_dsdx(3) = glmax(sxm1,npts)
      tmp_dsdx(4) = glmax(sym1,npts)
      if(nid.eq.0) then
        write(*,*)'Lan>> Jacdx = dx1v/2 = ',CS_Jacdx
        write(*,*)'Lan>> test dsdx 11/max',rxm1(1,1,1,1),tmp_dsdx(1)
        write(*,*)'Lan>> test dsdx 12/max',rym1(1,1,1,1),tmp_dsdx(2)
        write(*,*)'Lan>> test dsdx 21/max',sxm1(1,1,1,1),tmp_dsdx(3)
        write(*,*)'Lan>> test dsdx 22/max',sym1(1,1,1,1),tmp_dsdx(4)
      endif


c     wind field vectors
      CS_u_0 = 2.0*pi*BigR  ! check if needed divided by time
c      CS_u_0 = 1.0  ! check if needed divided by time
      alpha_0 = 0.0 !-pi/6.0 !-pi/4
      CS_delta = 1.0
      cs_alpha0 = cos(alpha_0)
      sn_alpha0 = sin(alpha_0)
      do i = 1,npts
         arg1 = EqAngAlpha(i,1,1,1)
         arg2 = EqAngBeta (i,1,1,1)

C        compute V_long V_lata, checked, Lan
         V_long(i) = CS_u_0 * (cs_alpha0 *cs_lati(i)
     $      + sn_alpha0 * cs_long(i) * sn_lati(i))
         V_lati(i) = -CS_u_0 * sn_alpha0 *sn_long(i)
            V_long_tmp = V_long(i)
            V_lati_tmp = V_lati(i)
         Vabs(i) = sqrt(V_long_tmp**2 + V_lati_tmp**2)

         CS_V_x(i) = -V_long_tmp * sn_long(i)
     $               -V_lati_tmp * sn_lati(i) * cs_long(i)
         CS_V_y(i) =  V_long_tmp * cs_long(i)
     $               -V_lati_tmp * sn_lati(i) * sn_long(i)
         CS_V_z(i) =  V_lati_tmp * cs_lati(i)

         CS_u1(i) = CS_ainv11(i) * V_long(i)
     $            + CS_ainv12(i) * V_lati(i)
         CS_u2(i) = CS_ainv21(i) * V_long(i)
     $            + CS_ainv22(i) * V_lati(i)

         CS_h(i)  = exp( -2.0*BigR**2/CS_delta**2
     $                  *(1-cs_lati(i)*cs_long(i)))
      enddo

C     Test div
      call rone (tmp_v,npts)

      call CS_cem_div(div_out,CS_w1,CS_w2,CS_u1,CS_u2,tmp_v,CS_Jac)

      amax_div = glamax(div_out,npts)
      amax_w1  = glamax(CS_w1,npts)
      amax_w2  = glamax(CS_w2,npts)

      if(nid.eq.0) write(*,*)'Lcheck div test(div=0), amax div= '
     $                       ,amax_div

C     Test div 2
      do i=1,npts
        ex_div(i)    = -CS_u_0*2.0*sn_long(i)*BigR/CS_delta**2 * CS_h(i)
        ex_div(i)    =  ex_div(i)*cs_lati(i)   ! avoid singularity
      enddo
      call CS_cem_div(div_out2,CS2_w1,CS2_w2,CS_u1,cs_u2,CS_h,CS_Jac)

      call col2(div_out,cs_lati,npts)
      call sub3(tmp_div,ex_div,div_out2,npts)

      amax2_div = glamax(tmp_div,npts)
      amax2_w1  = glamax(div_out2,npts)
      amax2_w2  = glamax(ex_div,npts)

      if(nid.eq.0) write(*,*)'Lcheck div test(cos*div=exact): Linf err='
     $                  ,amax2_div

cC     print coordinates
c        write(*,*)'Lan, check diff mat'
c        write(*,*)'format, i,j,ie,(x,y,z)'
c      do ie = 1,nelt
c      do j = 1,ny1
c      do i = 1,nx1
c        write(*,*)i,j,ie,xm1(i,j,1,ie),ym1(i,j,1,ie),zm1(i,j,1,ie)
c      enddo
c      write(*,*)'===================================================='
c      enddo
c      enddo

 133  format(2i3,i2,3f23.15)

      return
      end
c-----------------------------------------------------------------------
