c-----------------------------------------------------------------------
c
c     Box geometry with periodic boundary conditions.
c
c-----------------------------------------------------------------------
      subroutine userinc(tt,incfhx,incfhy,incfhz,incfex,incfey,incfez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real incfhx(lxzfl),incfhy(lxzfl),incfhz(lxzfl)
      real incfex(lxzfl),incfey(lxzfl),incfez(lxzfl)

      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt,hx,hy,hz,ex,ey,ez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'

      real tt
      real hx(lpts),hy(lpts),hz(lpts)
      real ex(lpts),ey(lpts),ez(lpts)

      call usersol(tt,hx,hy,hz,ex,ey,ez)

      return
      end
c-----------------------------------------------------------------------
      subroutine usersol(tt,solhx,solhy,solhz,solex,soley,solez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'CUBESPHERE'

      real tt
      real solhx(lpts),solhy(lpts),solhz(lpts)
      real solex(lpts),soley(lpts),solez(lpts)

      real omega,tmph,tmpe
      real xx,yy,zz
      integer i,n

      n = nx1*ny1*nz1*nelt


      call copy(HN(1,1),CS_h,n)
      call copy(HN(1,2),CS_V_u1,n)
      call copy(HN(1,3),CS_V_u2,n)
      call copy(solhx,CS_V_X,n)
      call copy(solhy,CS_V_Y,n)
      call copy(solhz,CS_V_Z,n)

      call copy(solex,CS_Jac,n)
      call copy(soley,CS_V_long,n)
      call copy(solez,CS_V_lati,n)


      return
      end
c-----------------------------------------------------------------------
      subroutine usersrc(tt,srchx,srchy,srchz,srcex,srcey,srcez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real srchx(lpts),srchy(lpts),srchz(lpts)
      real srcex(lpts),srcey(lpts),srcez(lpts)

      return
      end
c-----------------------------------------------------------------------
      subroutine userfsrc(tt,srcfhx,srcfhy,srcfhz,srcfex,srcfey,srcfez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real srcfhx(lxzfl),srcfhy(lxzfl),srcfhz(lxzfl)
      real srcfex(lxzfl),srcfey(lxzfl),srcfez(lxzfl)

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp(ix,iy,iz,iel)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

c     These don't do anything! This is a temporary measure until
c
c     https://github.com/NekCEM/NekCEM/issues/12
c
c     is resolved.
      integer ix,iy,iz,iel

      integer i

      do i = 1,npts
         permittivity(i) = 1.0
         permeability(i) = 1.0
      enddo

      if (nid.eq.0) write(*,*)'Lan>>usrvp here'
c     vvvvvv Cubed Sphere Basics
      call construct_cubespheregrid ! Lan, cube

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
c-----------------------------------------------------------------------
      implicit none

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      integer i,n
      real sx,sy,sz
      real glmin,glmax
      real xmin,ymin,zmin
      real xmax,ymax,zmax

      npts = nx1*ny1*nz1*nelt

c      xmin = glmin(xm1,n)
c      xmax = glmax(xm1,n)
c      ymin = glmin(ym1,n)
c      ymax = glmax(ym1,n)
c
c      sx = 2.0*pi/(xmax-xmin)
c      sy = 2.0*pi/(ymax-ymin)
c
c      do i = 1,n
c         xm1(i,1,1,1) = sx*(xm1(i,1,1,1)-xmin)
c         ym1(i,1,1,1) = sy*(ym1(i,1,1,1)-ymin)
c      enddo

c     Rescale Mesh: first face from [0,1] to [-pi/4,pi/4]

      xmin = glmin(xm1,npts)
      xmax = glmax(xm1,npts)
      ymin = glmin(ym1,npts)
      ymax = glmax(ym1,npts)

      if (nid.eq.0) then
        write(6,11)'Lcheck domain, range of rea (xmin/xmax)',xmin,xmax
        write(6,11)'Lcheck domain, range of rea (ymin/ymax)',ymin,ymax
      endif

      sx = 2.0*pi/(xmax-xmin)
      sy = 1.5*pi/(ymax-ymin)
      do i = 1,npts
         xm1(i,1,1,1) = sx*(xm1(i,1,1,1)-xmin)-pi/4
         ym1(i,1,1,1) = sy*(ym1(i,1,1,1)-ymin)-pi/4
      enddo

      xmin = glmin(xm1,npts)
      xmax = glmax(xm1,npts)
      ymin = glmin(ym1,npts)
      ymax = glmax(ym1,npts)
      if (nid.eq.0) then
        write(6,11)'Lcheck domain, range of EqAngBox (xmin/xmax)'
     $             ,xmin,xmax
        write(6,11)'Lcheck domain, range of EqAngBox (ymin/ymax)'
     $             ,ymin,ymax
      endif

   11 format(A,2f14.8)

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'RTIMER'

      integer i
      real l2(6),linf(6)
      real l2tol(6),linftol(6)

      if (ifte) then
         l2tol(1) = 0.0
         l2tol(2) = 0.0
         l2tol(3) = 5e-8
         l2tol(4) = 5e-8
         l2tol(5) = 5e-8
         l2tol(6) = 0.0

         linftol(1) = 0.0
         linftol(2) = 0.0
         linftol(3) = 5e-7
         linftol(4) = 5e-7
         linftol(5) = 5e-7
         linftol(6) = 0.0
      elseif (iftm) then
         l2tol(1) = 5e-8
         l2tol(2) = 5e-8
         l2tol(3) = 0.0
         l2tol(4) = 0.0
         l2tol(6) = 5e-8

         linftol(1) = 5e-7
         linftol(2) = 5e-7
         linftol(3) = 0.0
         linftol(4) = 0.0
         linftol(5) = 0.0
         linftol(6) = 5e-7
      else
         write(*,*) 'ERROR: userchk: invalid imode'
         call exitt(1)
      endif

      if (istep.le.10.or.mod(istep,iocomm).eq.0) then
         call usersol
     $     (time,shn(1,1),shn(1,2),shn(1,3),sen(1,1),sen(1,2),sen(1,3))

!$ACC UPDATE HOST(hn,en,shn,sen)
         call cem_error(hn(1,1),shn(1,1),errhn(1,1),npts,l2(1),linf(1))
         call cem_error(hn(1,2),shn(1,2),errhn(1,2),npts,l2(2),linf(2))
         call cem_error(hn(1,3),shn(1,3),errhn(1,3),npts,l2(3),linf(3))
         call cem_error(en(1,1),sen(1,1),erren(1,1),npts,l2(4),linf(4))
         call cem_error(en(1,2),sen(1,2),erren(1,2),npts,l2(5),linf(5))
         call cem_error(en(1,3),sen(1,3),erren(1,3),npts,l2(6),linf(6))

         call userprint(istep,time,dt,l2,linf,cpu_t,cpu_p_t)

         if (istep.eq.nsteps) then
           do i = 1,6
              if (l2(i).gt.l2tol(i)) call exitt(1)
              if (linf(i).gt.linftol(i)) call exitt(1)
           enddo
         endif
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userprint(istep,tt,dt,l2,linf,t1,t2)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      integer istep
      real tt,dt,t1,t2
      real l2(6),linf(6)

      integer k

      if (nid.eq.0) then
         write(6,101) istep,nelt,nx1-1,npts,tt,dt,(l2(k),k=1,6),t1,t2
         write(6,102) istep,nelt,nx1-1,npts,tt,dt,(linf(k),k=1,6),t1,t2
      endif

 101  format(/,i10,i6,i4,i9,1p9e10.3,e9.2,' CPU: L2')
 102  format(  i10,i6,i4,i9,1p9e10.3,e9.2,' CPU: Linf')

      return
      end
c-----------------------------------------------------------------------
      subroutine construct_cubespheregrid
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
c      include 'POISSON'
      include 'CUBESPHERE'

      common /my_output/ div_out (lx1*ly1*lz1*lelt)
     $               ,   div_out1(lx1*ly1*lz1*lelt)
     $               ,   div_out2(lx1*ly1*lz1*lelt)
     $               ,   CS_w1   (lx1*ly1*lz1*lelt)
     $               ,   CS_w2   (lx1*ly1*lz1*lelt)
     $               ,   CS2_w1  (lx1*ly1*lz1*lelt)
     $               ,   CS2_w2  (lx1*ly1*lz1*lelt)
     $               ,   ex_div (lx1*ly1*lz1*lelt)
   
      integer i,j,k,l,ie,ieg
      integer mx,my,mz
      integer ierr,NEL,iglsum
      real rscale,ex_div
      real xmin,ymin,zmin,xmax,ymax,zmax
      real xx,yy,zz,rr
      real FaceNum, xshift, yshift
      real glsum,glmax,glmin,glamax
      real tmp_dsdx(4)
      real CS_Jacdx
      real surf_area
      real tmp  (lx1*ly1*lz1*lelt)
      real tmp_f(lx1*ly1*lz1*lelt)
      real CS_xtmp,CS_ytmp,CS_rtmp
      real CubeSphXtmp,CubeSphYtmp,CubeSphZtmp
      real V_lati_tmp,V_long_tmp
      real CS_u_0,CS_delta
      real alpha_0,sn_alpha0,cs_alpha0
      real CS_Atmp
      real arg1,arg2
      real dx1v
      real div_out,div_out1,CS_w1,CS_w2
      real div_out2,CS2_w1,CS2_w2
     $   , tmp_v   (lx1*ly1*lz1*lelt)
     $   , test_long(lx1*ly1*lz1*lelt)
     $   , test_lati(lx1*ly1*lz1*lelt)
     $   , test_u1(lx1*ly1*lz1*lelt)
     $   , test_u2(lx1*ly1*lz1*lelt)
     $   , tmp_div(lx1*ly1*lz1*lelt)
      real amax_w1,amax_w2,amax_div
      real amax2_w1,amax2_w2,amax2_div
      real tmp_result
      real tmp_result2
      real tmpc1,tmpc2
      real eps

      real NpoleX,NpoleY,NpoleZ
      real SpoleX,SpoleY,SpoleZ
      real tt_dist1,tt_dist2

C     LLLLLLLLL

      nxyz = nx1*ny1*nz1
      npts = nxyz*nelt

C     Determine face id
      do ie = 1,nelt
        xx = (xm1(1,1,1,ie)+xm1(nx1,ny1,1,ie))*0.5
        yy = (ym1(1,1,1,ie)+ym1(nx1,ny1,1,ie))*0.5
        if_in_region(ie) = 0

        if (xx.gt.(-0.25*pi).AND.xx.lt.(0.25*pi)) then
          if (yy.gt.(-0.25*pi).AND.yy.lt.(0.25*pi)) then
            if_in_region(ie) = 1
          else
            write(*,*)'Lan, if_in_region err,nid,ie,xx,yy',nid,ie,xx,yy
          endif
        elseif (xx.lt.(0.75*pi)) then
          if (yy.gt.(-0.25*pi).AND.yy.lt.(0.25*pi)) then
            if_in_region(ie) = 2
          elseif (yy.gt.(0.25*pi).AND.yy.lt.(0.75*pi)) then
            if_in_region(ie) = 3
          else
            write(*,*)'Lan, if_in_region err,nid,ie,xx,yy',nid,ie,xx,yy
          endif
        elseif (xx.lt.(1.25*pi)) then
          if (yy.gt.(0.25*pi).AND.yy.lt.(0.75*pi)) then
            if_in_region(ie) = 4
          elseif (yy.gt.(0.75*pi).AND.yy.lt.(1.25*pi)) then
            if_in_region(ie) = 5
          else
            write(*,*)'Lan, if_in_region err,nid,ie,xx,yy',nid,ie,xx,yy
          endif
        elseif (xx.lt.(1.75*pi)) then
          if (yy.gt.(0.75*pi).AND.yy.lt.(1.25*pi)) then
            if_in_region(ie) = 6
          else
            write(*,*)'Lan, if_in_region err,nid,ie,xx,yy',nid,ie,xx,yy
          endif
        else
          write(*,*)'Lan, if_in_region err,nid,ie,xx,yy',nid,ie,xx,yy
        endif
      enddo

c     compute equal angular alpha and beta
      do ie = 1,nelt
        if (if_in_region(ie).eq.1) then  ! face 1
          xshift = 0.0
          yshift = 0.0
        elseif (if_in_region(ie).eq.2) then ! face 2
          xshift = 0.5*pi
          yshift = 0.0
        elseif (if_in_region(ie).eq.3) then ! face 3
          xshift = 0.5*pi
          yshift = 0.5*pi
        elseif (if_in_region(ie).eq.4) then ! face 4
          xshift = pi
          yshift = 0.5*pi
        elseif (if_in_region(ie).eq.5) then ! face 5
          xshift = pi
          yshift = pi
        elseif (if_in_region(ie).eq.6) then ! face 6
          xshift = 1.5*pi
          yshift = pi
        else
          if(nid.eq.0)write(*,*)'Lan, error in if_in_region2'
     $                        ,if_in_region(ie)
        endif

        do j = 1,nxyz
          i = j + (ie-1)*nxyz
          EqAngAlph(i) = xm1(i,1,1,1) - xshift
          EqAngBeta(i) = ym1(i,1,1,1) - yshift
        enddo
      enddo

c     compute spherical coordinate
      BigR = param(3) ! Lan, tmp, radius of sphere
      CubeLength = BigR/sqrt(3.0)
      if (nid.eq.0) write(6,*)'Lcheck SphR = ',BigR
      if (nid.eq.0) write(6,*)'Lcheck CubeLength = ',CubeLength

      do ie = 1,nelt
        if (if_in_region(ie).eq.1) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            CS_xtmp = CubeLength * tan(EqAngAlph(i))
            CS_ytmp = CubeLength * tan(EqAngBeta(i))
            CS_rtmp = sqrt(
     $                CubeLength**2 + CS_xtmp**2 + CS_ytmp**2)
            CubeSphX(i) =  BigR * CubeLength / CS_rtmp
            CubeSphY(i) =  BigR * CS_xtmp / CS_rtmp
            CubeSphZ(i) =  BigR * CS_ytmp / CS_rtmp
          enddo
        elseif (if_in_region(ie).eq.2) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            CS_xtmp = CubeLength * tan(EqAngAlph(i))
            CS_ytmp = CubeLength * tan(EqAngBeta(i))
            CS_rtmp = sqrt(
     $                CubeLength**2 + CS_xtmp**2 + CS_ytmp**2)
            CubeSphX(i) = -BigR * CS_xtmp / CS_rtmp
            CubeSphY(i) =  BigR * CubeLength / CS_rtmp
            CubeSphZ(i) =  BigR * CS_ytmp / CS_rtmp
          enddo
        elseif (if_in_region(ie).eq.3) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            CS_xtmp = CubeLength * tan(EqAngAlph(i))
            CS_ytmp = CubeLength * tan(EqAngBeta(i))
            CS_rtmp = sqrt(
     $                CubeLength**2 + CS_xtmp**2 + CS_ytmp**2)
            CubeSphX(i) = -BigR * CS_xtmp / CS_rtmp
            CubeSphY(i) = -BigR * CS_ytmp / CS_rtmp
            CubeSphZ(i) =  BigR * CubeLength / CS_rtmp
          enddo
        elseif (if_in_region(ie).eq.4) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            CS_xtmp = CubeLength * tan(EqAngAlph(i))
            CS_ytmp = CubeLength * tan(EqAngBeta(i))
            CS_rtmp = sqrt(
     $                CubeLength**2 + CS_xtmp**2 + CS_ytmp**2)
            CubeSphX(i) = -BigR * CubeLength / CS_rtmp
            CubeSphY(i) = -BigR * CS_ytmp / CS_rtmp
            CubeSphZ(i) = -BigR * CS_xtmp / CS_rtmp
          enddo
        elseif (if_in_region(ie).eq.5) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            CS_xtmp = CubeLength * tan(EqAngAlph(i))
            CS_ytmp = CubeLength * tan(EqAngBeta(i))
            CS_rtmp = sqrt(
     $                CubeLength**2 + CS_xtmp**2 + CS_ytmp**2)
            CubeSphX(i) =  BigR * CS_ytmp / CS_rtmp
            CubeSphY(i) = -BigR * CubeLength / CS_rtmp
            CubeSphZ(i) = -BigR * CS_xtmp / CS_rtmp
          enddo
        elseif (if_in_region(ie).eq.6) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            CS_xtmp = CubeLength * tan(EqAngAlph(i))
            CS_ytmp = CubeLength * tan(EqAngBeta(i))
            CS_rtmp = sqrt(
     $                CubeLength**2 + CS_xtmp**2 + CS_ytmp**2)
            CubeSphX(i) =  BigR * CS_ytmp / CS_rtmp
            CubeSphY(i) =  BigR * CS_xtmp / CS_rtmp
            CubeSphZ(i) = -BigR * CubeLength / CS_rtmp
          enddo
        else
          if(nid.eq.0)write(*,*)'Lan, error in if_in_region3'
     $                        ,if_in_region(ie)
        endif
      enddo

      call copy(xm1,CubeSphX,npts)
      call copy(ym1,CubeSphY,npts)
      call copy(zm1,CubeSphZ,npts)
      call copy(xmn,CubeSphX,npts)
      call copy(ymn,CubeSphY,npts)
      call copy(zmn,CubeSphZ,npts)

      eps = 1E-12

c     longitudes and latitudes
      do i = 1,npts
        CubeSphXtmp = CubeSphX(i)
        CubeSphYtmp = CubeSphY(i)
        CubeSphZtmp = CubeSphZ(i)
        long(i) = atan2(CubeSphYtmp, CubeSphXtmp)
        lati(i) = atan2(CubeSphZtmp,
     $     sqrt(CubeSphXtmp**2  + CubeSphYtmp**2))
        sn_long(i) = sin(long(i))
        cs_long(i) = cos(long(i))
        sn_lati(i) = sin(lati(i))
        cs_lati(i) = cos(lati(i))
      enddo


cc     fix north/south pole
c      NpoleZ = glmax(CubeSphZ,npts)
c      SpoleZ = glmin(CubeSphZ,npts)
c      if (nid.eq.0) then
c        write(*,*)'Lan>> (NpoleZ,SpoleZ) =',NpoleZ,SpoleZ
c      endif 
c      do i=1,npts
c        xx = CubeSphX(i)
c        yy = CubeSphY(i)
c        zz = CubeSphZ(i)
c
c        tt_dist1 = abs(zz-NpoleZ)
c        tt_dist2 = abs(zz-SpoleZ)
c
c        if (tt_dist1.lt.1E-6) then 
c          write(*,*)'Lan, find a N-pole',
c     $      '(xx,yy,zz)',xx,yy,zz,'long',long(i)
c        endif
c        if (tt_dist2.lt.1E-6) then
c          write(*,*)'Lan, find a S-pole',
c     $      '(xx,yy,zz)',xx,yy,zz,'long',long(i)
c        endif
c      enddo



c     A matrix
      do ie = 1,nelt
        if ( if_in_region(ie) .eq. 1 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlph(i)
            arg2 = EqAngBeta(i)
            CS_A_11(i) =  BigR 
     $         * cs_long(i)**2 * cs_lati(i) / cos(arg1)**2
            CS_A_12(i) =  0.0
            CS_A_21(i) = -BigR 
     $         * sn_long(i) * cs_long(i)
     $         * sn_lati(i) * cs_lati(i)    / cos(arg1)**2
            CS_A_22(i) =  BigR 
     $         * cs_long(i) * cs_lati(i)**2 / cos(arg2)**2
          enddo
        elseif ( if_in_region(ie) .eq. 2 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlph(i)
            arg2 = EqAngBeta(i)
            CS_A_11(i) = BigR 
     $         * sn_long(i)**2 * cs_lati(i) / cos(arg1)**2
            CS_A_12(i) =  0.0
            CS_A_21(i) = BigR 
     $         * sn_long(i) * cs_long(i) 
     $         * sn_lati(i) * cs_lati(i)    / cos(arg1)**2
            CS_A_22(i) = BigR 
     $         * sn_long(i) * cs_lati(i)**2 / cos(arg2)**2
            enddo
        elseif ( if_in_region(ie) .eq. 3 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlph(i)
            arg2 = EqAngBeta(i)
            CS_A_11(i) =  BigR
     $         * sn_long(i) * sn_lati(i)    / cos(arg1)**2
            CS_A_12(i) = -BigR 
     $         * cs_long(i) * sn_lati(i)    / cos(arg2)**2
            CS_A_21(i) =  BigR 
     $         * cs_long(i) * sn_lati(i)**2 / cos(arg1)**2
            CS_A_22(i) = BigR 
     $         * sn_long(i) * sn_lati(i)**2 / cos(arg2)**2
          enddo
        elseif ( if_in_region(ie) .eq. 4 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlph(i)
            arg2 = EqAngBeta(i)
            CS_A_11(i) =  0.0
            CS_A_12(i) =  BigR
     $          * cs_long(i)**2* cs_lati(i) / cos(arg2)**2
            CS_A_21(i) = BigR 
     $         * cs_long(i) * cs_lati(i)**2 / cos(arg1)**2
            CS_A_22(i) = -BigR 
     $         * sn_long(i) * cs_long(i)
     $         * sn_lati(i) * cs_lati(i)    / cos(arg2)**2
          enddo
        elseif ( if_in_region(ie) .eq. 5 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlph(i)
            arg2 = EqAngBeta(i)
            CS_A_11(i) =  0.0
            CS_A_12(i) = BigR 
     $         * sn_long(i)**2 * cs_lati(i) / cos(arg2)**2
            CS_A_21(i) = BigR 
     $         * sn_long(i) * cs_lati(i)**2 / cos(arg1)**2
            CS_A_22(i) = BigR 
     $         * sn_long(i) * cs_long(i)
     $         * sn_lati(i) * cs_lati(i)    / cos(arg2)**2
            enddo
        elseif ( if_in_region(ie) .eq. 6 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlph(i)
            arg2 = EqAngBeta(i)
            CS_A_11(i) = -BigR
     $         * cs_long(i) * sn_lati(i)    / cos(arg1)**2
            CS_A_12(i) = BigR
     $         * sn_long(i) * sn_lati(i)    / cos(arg2)**2
            CS_A_21(i) = BigR 
     $         * sn_long(i) * sn_lati(i)**2 / cos(arg1)**2
            CS_A_22(i) = BigR 
     $         * cs_long(i) * sn_lati(i)**2 / cos(arg2)**2
          enddo
        endif
      enddo

c     Compute inv(A) and Jacobian
      do i=1,npts   ! compute inv(A)
            CS_Atmp = CS_A_11(i)*CS_A_22(i)
     $              - CS_A_12(i)*CS_A_21(i)
         CS_ainv11(i) =  CS_A_22(i)/CS_Atmp
         CS_ainv12(i) = -CS_A_12(i)/CS_Atmp
         CS_ainv21(i) = -CS_A_21(i)/CS_Atmp
         CS_ainv22(i) =  CS_A_11(i)/CS_Atmp

         CS_Jac(i,1,1,1) = abs(CS_Atmp)
c         CS_Jac(i,1,1,1) = BigR**2 / cos(arg1)**2 / cos(arg2)**2
c     $      / ( 1.0 + tan(arg1)**2 + tan(arg2)**2 )**1.5
      enddo

C     Test and replace d(rst)/d(xyz)
      if(nid.eq.0) write(*,*)'Lan>> chk Jac start'
      do ie=1,nelt
        call CHKJAC(CS_Jac(1,1,1,ie),nxyz,ie,xm1,ym1,zm1,ndim,ierr)
      enddo

      if (nid.eq.0) write(*,*)'Lan>> Jac old: jacm,jacm1'
     $             ,jacm(1),jacm1(1,1,1,1)

      call col2(jacm1,CS_Jac,npts)
      call col2(jacm,CS_Jac,npts)
      call col2(bmn,CS_Jac,npts)
      call copy(bm1,bmn,npts)

      if (nid.eq.0) write(*,*)'Lan>> Jac new: jacm,jacm1'
     $             ,jacm(1),jacm1(1,1,1,1)

c     Check surface area
      surf_area = glsum(bmn,npts)
      if (nid.eq.0) write(*,*)'Lcheck surf area=',surf_area,
     $                        'exact: 4piR=',4.0*pi*BigR**2
c     Check integral: int (x-1)**2 + yy**2 + zz**2 dS = 4*pi*R^2*(R^2+1)
      do i=1,npts
        xx = CubeSphX (i)
        yy = CubeSphY (i)
        zz = CubeSphZ (i)
        tmp_f(i) = (xx-1.0)**2 + yy**2 + zz**2
      enddo
      call col3(tmp,tmp_f,bmn,npts)
      tmp_result = glsum(tmp,npts)
      if (nid.eq.0) then
        write(*,*)'Lcheck>> ==========================================='
        write(*,*)'Lcheck>> [An execise:'
        write(*,*)'Lcheck>> [ int (x-1)**2 + yy**2 + zz**2 dS'
        write(*,*)'Lcheck>> [ the numerical integral is',tmp_result
        write(*,*)'Lcheck>> [   ans:   4*pi*R^2(R^2+1)='
     $            ,4.0*pi*BigR**2*(BigR**2+1.0)
        write(*,*)'Lcheck>> ==========================================='
      endif

C     Test and replace d(rst)/d(xyz), ToDo: replace later by Lan
      nel = iglsum(nelt,1)
      dx1v = (pi/sqrt(nel/6.0))/2.0
      CS_Jacdx = dx1v/2
      tmp_dsdx(1) = glmax(rxm1,npts)
      tmp_dsdx(2) = glmax(rym1,npts)
      tmp_dsdx(3) = glmax(sxm1,npts)
      tmp_dsdx(4) = glmax(sym1,npts)
      if(nid.eq.0) then
        write(*,*)'Lan>> Jacdx = dx1v/2 = ',CS_Jacdx
        write(*,*)'Lan>> test dsdx 11/max',rxm1(1,1,1,1),tmp_dsdx(1)
        write(*,*)'Lan>> test dsdx 12/max',rym1(1,1,1,1),tmp_dsdx(2)
        write(*,*)'Lan>> test dsdx 21/max',sxm1(1,1,1,1),tmp_dsdx(3)
        write(*,*)'Lan>> test dsdx 22/max',sym1(1,1,1,1),tmp_dsdx(4)
      endif


c     wind field vectors
      CS_u_0 = 2.0*pi*BigR  ! check if needed divided by time
c      CS_u_0 = 1.0  ! check if needed divided by time
      alpha_0 = -pi/4
      CS_delta = 0.5
      cs_alpha0 = cos(alpha_0)
      sn_alpha0 = sin(alpha_0)
      do i = 1,npts
         arg1 = EqAngAlph(i)
         arg2 = EqAngBeta(i)

C        compute V_long V_lati, checked, Lan
         CS_V_long(i) = CS_u_0 * (cs_alpha0 *cs_lati(i)
     $      + sn_alpha0 * cs_long(i) * sn_lati(i))
         CS_V_lati(i) = -CS_u_0 * sn_alpha0 *sn_long(i)
            V_long_tmp = CS_V_long(i)
            V_lati_tmp = CS_V_lati(i)
         CS_V_abs(i) = sqrt(V_long_tmp**2 + V_lati_tmp**2)

         CS_V_X(i) = -V_long_tmp * sn_long(i)
     $               -V_lati_tmp * sn_lati(i) * cs_long(i)
         CS_V_Y(i) =  V_long_tmp * cs_long(i)
     $               -V_lati_tmp * sn_lati(i) * sn_long(i)
         CS_V_Z(i) =  V_lati_tmp * cs_lati(i)

         CS_V_u1(i) = CS_ainv11(i) * CS_V_long(i)
     $              + CS_ainv12(i) * CS_V_lati(i)
         CS_V_u2(i) = CS_ainv21(i) * CS_V_long(i)
     $              + CS_ainv22(i) * CS_V_lati(i)

         CS_h(i)  = exp( -2.0*BigR**2/CS_delta**2
     $                  *(1-cs_lati(i)*cs_long(i)))
      enddo

C     Test div
      call rone (tmp_v,npts)

      call CS_cem_div_skew_sym(div_out,CS_w1,CS_w2,
     $                         CS_V_u1,CS_V_u2,tmp_v,CS_Jac)

      amax_div = glamax(div_out,npts)
      amax_w1  = glamax(CS_w1,npts)
      amax_w2  = glamax(CS_w2,npts)

      if(nid.eq.0) write(*,*)'Lcheck div test(div=0), amax div= '
     $                       ,amax_div

C     Test div 2
      do i=1,npts
        ex_div(i)    = -CS_u_0*2.0*sn_long(i)*BigR/CS_delta**2 * CS_h(i)
        ex_div(i)    =  ex_div(i)*cs_lati(i)
      enddo
      call CS_cem_div(div_out2,CS2_w1,CS2_w2
     $               ,CS_V_u1,CS_V_u2,CS_h,CS_Jac)

      call sub3(tmp_div,ex_div,div_out2,npts)

      amax2_div = glamax(tmp_div,npts)
      amax2_w1  = glamax(div_out2,npts)
      amax2_w2  = glamax(ex_div,npts)

      if(nid.eq.0) write(*,*)
     $   'Lcheck div test(cos*div=exact) (alpha=0): Linf err=',amax2_div

cC     print coordinates
c        write(*,*)'Lan, check diff mat'
c        write(*,*)'format, i,j,ie,(x,y,z)'
c      do ie = 1,nelt
c      do j = 1,ny1
c      do i = 1,nx1
c        write(*,*)i,j,ie,xm1(i,j,1,ie),ym1(i,j,1,ie),zm1(i,j,1,ie)
c      enddo
c      write(*,*)'===================================================='
c      enddo
c      enddo

 133  format(2i3,i2,3f23.15)

      return
      end
c-----------------------------------------------------------------------
