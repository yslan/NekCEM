c-----------------------------------------------------------------------
c
c     2d cubed sphere simulation
c     input mesh: 2d surface of dice (ladder shape)
c
c-----------------------------------------------------------------------
      subroutine userinc(tt,incfhx,incfhy,incfhz,incfex,incfey,incfez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real incfhx(lxzfl),incfhy(lxzfl),incfhz(lxzfl)
      real incfex(lxzfl),incfey(lxzfl),incfez(lxzfl)

      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt,hx,hy,hz,ex,ey,ez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'CUBESPHERE' ! ToDo: use local variables, Lan

      real tt
      real hx(lpts),hy(lpts),hz(lpts)
      real ex(lpts),ey(lpts),ez(lpts)
      real u0,alpha,delta

c     Compute ini field
      u0 = 2.0*pi*SphR
      alpha = -pi/4.0
      delta = 0.5

      call get_one_way_wind(CS_V_long,CS_V_lati,CS_V_X,CS_V_Y,CS_V_Z
     $                     ,CS_V_u1,CS_V_u2,alpha,u0)
      call get_testcase_h(CS_h,SphR,delta)

c     output step 0
      call usersol(tt,hx,hy,hz,ex,ey,ez)

      return
      end
c-----------------------------------------------------------------------
      subroutine usersol(tt,solhx,solhy,solhz,solex,soley,solez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'CUBESPHERE'

      real tt
      real solhx(lpts),solhy(lpts),solhz(lpts)
      real solex(lpts),soley(lpts),solez(lpts)

      real omega,tmph,tmpe
      real xx,yy,zz
      integer i,n

      n = nx1*ny1*nz1*nelt

      call copy(HN(1,1),CS_h,n)
      call copy(HN(1,2),CS_V_u1,n)
      call copy(HN(1,3),CS_V_u2,n)
      call copy(solhx,CS_V_X,n)
      call copy(solhy,CS_V_Y,n)
      call copy(solhz,CS_V_Z,n)

      call copy(solex,CS_Jac,n)
      call copy(soley,CS_V_long,n)
      call copy(solez,CS_V_lati,n)

      return
      end
c-----------------------------------------------------------------------
      subroutine usersrc(tt,srchx,srchy,srchz,srcex,srcey,srcez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real srchx(lpts),srchy(lpts),srchz(lpts)
      real srcex(lpts),srcey(lpts),srcez(lpts)

      return
      end
c-----------------------------------------------------------------------
      subroutine userfsrc(tt,srcfhx,srcfhy,srcfhz,srcfex,srcfey,srcfez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real srcfhx(lxzfl),srcfhy(lxzfl),srcfhz(lxzfl)
      real srcfex(lxzfl),srcfey(lxzfl),srcfez(lxzfl)

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp(ix,iy,iz,iel)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      integer ix,iy,iz,iel

      integer i

      do i = 1,npts
         permittivity(i) = 1.0
         permeability(i) = 1.0
      enddo

c     Cubed Sphere Basics
      call construct_cubespheregrid ! Lan, cube
      call CS_adv_basic_tests       ! compute tests for div Jac

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
c-----------------------------------------------------------------------
      implicit none

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      integer i,n
      real sx,sy,sz
      real glmin,glmax
      real xmin,ymin,zmin
      real xmax,ymax,zmax

      npts = nx1*ny1*nz1*nelt


c     Rescale Mesh: first face from [0,1] to [-pi/4,pi/4]

      xmin = glmin(xm1,npts)
      xmax = glmax(xm1,npts)
      ymin = glmin(ym1,npts)
      ymax = glmax(ym1,npts)

      if (nid.eq.0) then
        write(6,11)'Lcheck domain, range of rea (xmin/xmax)',xmin,xmax
        write(6,11)'Lcheck domain, range of rea (ymin/ymax)',ymin,ymax
      endif

      sx = 2.0*pi/(xmax-xmin)
      sy = 1.5*pi/(ymax-ymin)
      do i = 1,npts
         xm1(i,1,1,1) = sx*(xm1(i,1,1,1)-xmin)-pi/4
         ym1(i,1,1,1) = sy*(ym1(i,1,1,1)-ymin)-pi/4
      enddo

      xmin = glmin(xm1,npts)
      xmax = glmax(xm1,npts)
      ymin = glmin(ym1,npts)
      ymax = glmax(ym1,npts)
      if (nid.eq.0) then
        write(6,11)'Lcheck domain, range of EqAngBox (xmin/xmax)'
     $             ,xmin,xmax
        write(6,11)'Lcheck domain, range of EqAngBox (ymin/ymax)'
     $             ,ymin,ymax
      endif

   11 format(A,2f14.8)

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'RTIMER'

      integer i
      real l2(6),linf(6)
      real l2tol(6),linftol(6)

      if (ifte) then
         l2tol(1) = 0.0
         l2tol(2) = 0.0
         l2tol(3) = 5e-8
         l2tol(4) = 5e-8
         l2tol(5) = 5e-8
         l2tol(6) = 0.0

         linftol(1) = 0.0
         linftol(2) = 0.0
         linftol(3) = 5e-7
         linftol(4) = 5e-7
         linftol(5) = 5e-7
         linftol(6) = 0.0
      elseif (iftm) then
         l2tol(1) = 5e-8
         l2tol(2) = 5e-8
         l2tol(3) = 0.0
         l2tol(4) = 0.0
         l2tol(6) = 5e-8

         linftol(1) = 5e-7
         linftol(2) = 5e-7
         linftol(3) = 0.0
         linftol(4) = 0.0
         linftol(5) = 0.0
         linftol(6) = 5e-7
      else
         write(*,*) 'ERROR: userchk: invalid imode'
         call exitt(1)
      endif

      if (istep.le.10.or.mod(istep,iocomm).eq.0) then
         call usersol
     $     (time,shn(1,1),shn(1,2),shn(1,3),sen(1,1),sen(1,2),sen(1,3))

!$ACC UPDATE HOST(hn,en,shn,sen)
         call cem_error(hn(1,1),shn(1,1),errhn(1,1),npts,l2(1),linf(1))
         call cem_error(hn(1,2),shn(1,2),errhn(1,2),npts,l2(2),linf(2))
         call cem_error(hn(1,3),shn(1,3),errhn(1,3),npts,l2(3),linf(3))
         call cem_error(en(1,1),sen(1,1),erren(1,1),npts,l2(4),linf(4))
         call cem_error(en(1,2),sen(1,2),erren(1,2),npts,l2(5),linf(5))
         call cem_error(en(1,3),sen(1,3),erren(1,3),npts,l2(6),linf(6))

         call userprint(istep,time,dt,l2,linf,cpu_t,cpu_p_t)

         if (istep.eq.nsteps) then
           do i = 1,6
              if (l2(i).gt.l2tol(i)) call exitt(1)
              if (linf(i).gt.linftol(i)) call exitt(1)
           enddo
         endif
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userprint(istep,tt,dt,l2,linf,t1,t2)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      integer istep
      real tt,dt,t1,t2
      real l2(6),linf(6)

      integer k

      if (nid.eq.0) then
         write(6,101) istep,nelt,nx1-1,npts,tt,dt,(l2(k),k=1,6),t1,t2
         write(6,102) istep,nelt,nx1-1,npts,tt,dt,(linf(k),k=1,6),t1,t2
      endif

 101  format(/,i10,i6,i4,i9,1p9e10.3,e9.2,' CPU: L2')
 102  format(  i10,i6,i4,i9,1p9e10.3,e9.2,' CPU: Linf')

      return
      end
c-----------------------------------------------------------------------
c     This subroutine perform basic test to verified CS's settings.
c     Mainly test integral, divergent.
      subroutine CS_adv_basic_tests
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'CUBESPHERE'

      real xx,yy,zz
      real glsum,glamax

      real csh(lpts1)
      real vvx(lpts1),vvy(lpts1),vvz(lpts1)
      real vu1(lpts1),vu2(lpts1)
      real vlong(lpts1),vlati(lpts1)

      real u0, alpha, delta

      real w1(lpts1),w2(lpts1),tmp_v(lpts1)
      real tmp_f(lpts1),tmp_wf(lpts1)
      real tmp_result
      real surf_area

      real div_out(lpts1),div_out2(lpts1)
      real div_err(lpts1),ex_div(lpts1)
      real linf_div

      integer i,j,k,ie

      npts = nx1*ny1*nz1*nelt

c     Test CS_Jac
c     Test 1: test surface integral
      surf_area = glsum(bmn,npts)
      if (nid.eq.0) write(*,*)'Lcheck surf area=',surf_area,
     $                        'exact: 4piR=',4.0*pi*SphR**2

c     Test 2: int (x-1)**2 + yy**2 + zz**2 dS = 4*pi*R^2*(R^2+1)
      do i=1,npts
        xx = CubeSphX (i)
        yy = CubeSphY (i)
        zz = CubeSphZ (i)
        tmp_f(i) = (xx-1.0)**2 + yy**2 + zz**2
      enddo
      call col3(tmp_wf,tmp_f,bmn,npts)
      tmp_result = glsum(tmp_wf,npts)
      if (nid.eq.0) then
        write(*,*)'Lcheck>> ==========================================='
        write(*,*)'Lcheck>> [An execise:'
        write(*,*)'Lcheck>> [ int (x-1)**2 + yy**2 + zz**2 dS'
        write(*,*)'Lcheck>> [ the numerical integral is',tmp_result
        write(*,*)'Lcheck>> [   ans:   4*pi*R^2(R^2+1)='
     $            ,4.0*pi*SphR**2*(SphR**2+1.0)
        write(*,*)'Lcheck>> ==========================================='
      endif

c     Test div
      u0 = 2*pi*SphR
      alpha = 0.0
      delta = 0.5

      call get_one_way_wind(vlong,vlati,vvx,vvy,vvz,vu1,vu2,alpha,u0)
      call get_testcase_h(csh,SphR,delta)

c     Test 3: div(v) = 0
      call rone (tmp_v,npts)

      call CS_cem_div_skew_sym(div_out,w1,w2,Vu1,Vu2,tmp_v,CS_Jac)

      linf_div = glamax(div_out,npts)

      if(nid.eq.0) write(*,*)'Lcheck div test(div=0), amax div= '
     $                       ,linf_div

C     Test 4: div(vh)
      do i=1,npts
        ex_div(i)    = -2.0*u0*SphR*sn_long(i)/delta**2 * csh(i)
        ex_div(i)    =  ex_div(i) * cs_lati(i)
      enddo
      call CS_cem_div(div_out2,w1,w2,Vu1,Vu2,csh,CS_Jac)

      call sub3(div_err,ex_div,div_out2,npts)

      linf_div = glamax(div_err,npts)

      if(nid.eq.0) write(*,*)
     $   'Lcheck div test(cos*div=exact) (alpha=0): Linf err=',linf_div

c      Test Grid
cC     print coordinates
c        write(*,*)'Lan, check diff mat'
c        write(*,*)'format, i,j,ie,(x,y,z)'
c      do ie = 1,nelt
c      do j = 1,ny1
c      do i = 1,nx1
c        write(*,*)i,j,ie,xm1(i,j,1,ie),ym1(i,j,1,ie),zm1(i,j,1,ie)
c      enddo
c      write(*,*)'===================================================='
c      enddo
c      enddo

 133  format(2i3,i2,3f23.15)

      return
      end
c-----------------------------------------------------------------------
c     This routine construct the coordinates, jcaobian of CS
      subroutine construct_cubespheregrid
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'CUBESPHERE'

      integer i,j,k,l,ie,ieg
      integer ierr,NEL,iglsum
      real xx,yy,zz,rr,arg1,arg2
      real xmin,ymin,zmin,xmax,ymax,zmax
      real xshift,yshift
      real glsum,glmax,glmin,glamax
      real CS_Atmp
      real tmp_dsdx(4),Jacdx,dx1v

      real NpoleX,NpoleY,NpoleZ
      real SpoleX,SpoleY,SpoleZ
      real dist1,dist2

      nxyz = nx1*ny1*nz1
      npts = nxyz*nelt

C     Determine face id
      do ie = 1,nelt
        xx = (xm1(1,1,1,ie)+xm1(nx1,ny1,1,ie))*0.5
        yy = (ym1(1,1,1,ie)+ym1(nx1,ny1,1,ie))*0.5
        if_in_region(ie) = 0

        if (xx.gt.(-0.25*pi).AND.xx.lt.(0.25*pi)) then
          if (yy.gt.(-0.25*pi).AND.yy.lt.(0.25*pi)) then
            if_in_region(ie) = 1
          else
            write(*,*)'Lan, if_in_region err,nid,ie,xx,yy',nid,ie,xx,yy
          endif
        elseif (xx.lt.(0.75*pi)) then
          if (yy.gt.(-0.25*pi).AND.yy.lt.(0.25*pi)) then
            if_in_region(ie) = 2
          elseif (yy.gt.(0.25*pi).AND.yy.lt.(0.75*pi)) then
            if_in_region(ie) = 3
          else
            write(*,*)'Lan, if_in_region err,nid,ie,xx,yy',nid,ie,xx,yy
          endif
        elseif (xx.lt.(1.25*pi)) then
          if (yy.gt.(0.25*pi).AND.yy.lt.(0.75*pi)) then
            if_in_region(ie) = 4
          elseif (yy.gt.(0.75*pi).AND.yy.lt.(1.25*pi)) then
            if_in_region(ie) = 5
          else
            write(*,*)'Lan, if_in_region err,nid,ie,xx,yy',nid,ie,xx,yy
          endif
        elseif (xx.lt.(1.75*pi)) then
          if (yy.gt.(0.75*pi).AND.yy.lt.(1.25*pi)) then
            if_in_region(ie) = 6
          else
            write(*,*)'Lan, if_in_region err,nid,ie,xx,yy',nid,ie,xx,yy
          endif
        else
          write(*,*)'Lan, if_in_region err,nid,ie,xx,yy',nid,ie,xx,yy
        endif
      enddo

c     compute equal angular alpha and beta
      do ie = 1,nelt
        if (if_in_region(ie).eq.1) then  ! face 1
          xshift = 0.0
          yshift = 0.0
        elseif (if_in_region(ie).eq.2) then ! face 2
          xshift = 0.5*pi
          yshift = 0.0
        elseif (if_in_region(ie).eq.3) then ! face 3
          xshift = 0.5*pi
          yshift = 0.5*pi
        elseif (if_in_region(ie).eq.4) then ! face 4
          xshift = pi
          yshift = 0.5*pi
        elseif (if_in_region(ie).eq.5) then ! face 5
          xshift = pi
          yshift = pi
        elseif (if_in_region(ie).eq.6) then ! face 6
          xshift = 1.5*pi
          yshift = pi
        else
          if(nid.eq.0)write(*,*)'Lan, error in if_in_region2'
     $                        ,if_in_region(ie)
        endif

        do j = 1,nxyz
          i = j + (ie-1)*nxyz
          EqAngAlph(i) = xm1(i,1,1,1) - xshift
          EqAngBeta(i) = ym1(i,1,1,1) - yshift
        enddo
      enddo


c     compute coordinate on sphere
      SphR = param(3) ! Lan, tmp, radius of sphere
      CubeLength = SphR/sqrt(3.0)
      if (nid.eq.0) write(6,*)'Lcheck SphR = ',SphR
      if (nid.eq.0) write(6,*)'Lcheck CubeLength = ',CubeLength

      do ie = 1,nelt
        if (if_in_region(ie).eq.1) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            xx = CubeLength * tan(EqAngAlph(i))
            yy = CubeLength * tan(EqAngBeta(i))
            rr = sqrt(
     $                CubeLength**2 + xx**2 + yy**2)
            CubeSphX(i) =  SphR * CubeLength / rr
            CubeSphY(i) =  SphR * xx / rr
            CubeSphZ(i) =  SphR * yy / rr
          enddo
        elseif (if_in_region(ie).eq.2) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            xx = CubeLength * tan(EqAngAlph(i))
            yy = CubeLength * tan(EqAngBeta(i))
            rr = sqrt(
     $                CubeLength**2 + xx**2 + yy**2)
            CubeSphX(i) = -SphR * xx / rr
            CubeSphY(i) =  SphR * CubeLength / rr
            CubeSphZ(i) =  SphR * yy / rr
          enddo
        elseif (if_in_region(ie).eq.3) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            xx = CubeLength * tan(EqAngAlph(i))
            yy = CubeLength * tan(EqAngBeta(i))
            rr = sqrt(
     $                CubeLength**2 + xx**2 + yy**2)
            CubeSphX(i) = -SphR * xx / rr
            CubeSphY(i) = -SphR * yy / rr
            CubeSphZ(i) =  SphR * CubeLength / rr
          enddo
        elseif (if_in_region(ie).eq.4) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            xx = CubeLength * tan(EqAngAlph(i))
            yy = CubeLength * tan(EqAngBeta(i))
            rr = sqrt(
     $                CubeLength**2 + xx**2 + yy**2)
            CubeSphX(i) = -SphR * CubeLength / rr
            CubeSphY(i) = -SphR * yy / rr
            CubeSphZ(i) = -SphR * xx / rr
          enddo
        elseif (if_in_region(ie).eq.5) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            xx = CubeLength * tan(EqAngAlph(i))
            yy = CubeLength * tan(EqAngBeta(i))
            rr = sqrt(
     $                CubeLength**2 + xx**2 + yy**2)
            CubeSphX(i) =  SphR * yy / rr
            CubeSphY(i) = -SphR * CubeLength / rr
            CubeSphZ(i) = -SphR * xx / rr
          enddo
        elseif (if_in_region(ie).eq.6) then
          do j = 1,nxyz
            i = j + (ie-1)*nxyz
            xx = CubeLength * tan(EqAngAlph(i))
            yy = CubeLength * tan(EqAngBeta(i))
            rr = sqrt(
     $                CubeLength**2 + xx**2 + yy**2)
            CubeSphX(i) =  SphR * yy / rr
            CubeSphY(i) =  SphR * xx / rr
            CubeSphZ(i) = -SphR * CubeLength / rr
          enddo
        else
          if(nid.eq.0)write(*,*)'Lan, error in if_in_region3'
     $                        ,if_in_region(ie)
        endif
      enddo

      call copy(xm1,CubeSphX,npts)
      call copy(ym1,CubeSphY,npts)
      call copy(zm1,CubeSphZ,npts)
      call copy(xmn,CubeSphX,npts)
      call copy(ymn,CubeSphY,npts)
      call copy(zmn,CubeSphZ,npts)

c     longitudes and latitudes
      do i = 1,npts
        xx = CubeSphX(i)
        yy = CubeSphY(i)
        zz = CubeSphZ(i)
        long(i) = atan2(yy,xx)
        lati(i) = atan2(zz,sqrt(xx**2+yy**2))
        sn_long(i) = sin(long(i))
        cs_long(i) = cos(long(i))
        sn_lati(i) = sin(lati(i))
        cs_lati(i) = cos(lati(i))
      enddo


cc     fix north/south pole
c      NpoleZ = glmax(CubeSphZ,npts)
c      SpoleZ = glmin(CubeSphZ,npts)
c      if (nid.eq.0) then
c        write(*,*)'Lan>> (NpoleZ,SpoleZ) =',NpoleZ,SpoleZ
c      endif 
c      do i=1,npts
c        xx = CubeSphX(i)
c        yy = CubeSphY(i)
c        zz = CubeSphZ(i)
c
c        dist1 = abs(zz-NpoleZ)
c        dist2 = abs(zz-SpoleZ)
c
c        if (tt_dist1.lt.1E-6) then 
c          write(*,*)'Lan, find a N-pole',
c     $      '(xx,yy,zz)',xx,yy,zz,'long',long(i)
c        endif
c        if (tt_dist2.lt.1E-6) then
c          write(*,*)'Lan, find a S-pole',
c     $      '(xx,yy,zz)',xx,yy,zz,'long',long(i)
c        endif
c      enddo


c     A matrix
      do ie = 1,nelt
        if ( if_in_region(ie) .eq. 1 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlph(i)
            arg2 = EqAngBeta(i)
            CS_A_11(i) =  SphR 
     $         * cs_long(i)**2 * cs_lati(i) / cos(arg1)**2
            CS_A_12(i) =  0.0
            CS_A_21(i) = -SphR 
     $         * sn_long(i) * cs_long(i)
     $         * sn_lati(i) * cs_lati(i)    / cos(arg1)**2
            CS_A_22(i) =  SphR 
     $         * cs_long(i) * cs_lati(i)**2 / cos(arg2)**2
          enddo
        elseif ( if_in_region(ie) .eq. 2 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlph(i)
            arg2 = EqAngBeta(i)
            CS_A_11(i) = SphR 
     $         * sn_long(i)**2 * cs_lati(i) / cos(arg1)**2
            CS_A_12(i) =  0.0
            CS_A_21(i) = SphR 
     $         * sn_long(i) * cs_long(i) 
     $         * sn_lati(i) * cs_lati(i)    / cos(arg1)**2
            CS_A_22(i) = SphR 
     $         * sn_long(i) * cs_lati(i)**2 / cos(arg2)**2
            enddo
        elseif ( if_in_region(ie) .eq. 3 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlph(i)
            arg2 = EqAngBeta(i)
            CS_A_11(i) =  SphR
     $         * sn_long(i) * sn_lati(i)    / cos(arg1)**2
            CS_A_12(i) = -SphR 
     $         * cs_long(i) * sn_lati(i)    / cos(arg2)**2
            CS_A_21(i) =  SphR 
     $         * cs_long(i) * sn_lati(i)**2 / cos(arg1)**2
            CS_A_22(i) = SphR 
     $         * sn_long(i) * sn_lati(i)**2 / cos(arg2)**2
          enddo
        elseif ( if_in_region(ie) .eq. 4 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlph(i)
            arg2 = EqAngBeta(i)
            CS_A_11(i) =  0.0
            CS_A_12(i) =  SphR
     $          * cs_long(i)**2* cs_lati(i) / cos(arg2)**2
            CS_A_21(i) = SphR 
     $         * cs_long(i) * cs_lati(i)**2 / cos(arg1)**2
            CS_A_22(i) = -SphR 
     $         * sn_long(i) * cs_long(i)
     $         * sn_lati(i) * cs_lati(i)    / cos(arg2)**2
          enddo
        elseif ( if_in_region(ie) .eq. 5 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlph(i)
            arg2 = EqAngBeta(i)
            CS_A_11(i) =  0.0
            CS_A_12(i) = SphR 
     $         * sn_long(i)**2 * cs_lati(i) / cos(arg2)**2
            CS_A_21(i) = SphR 
     $         * sn_long(i) * cs_lati(i)**2 / cos(arg1)**2
            CS_A_22(i) = SphR 
     $         * sn_long(i) * cs_long(i)
     $         * sn_lati(i) * cs_lati(i)    / cos(arg2)**2
            enddo
        elseif ( if_in_region(ie) .eq. 6 ) then
          do j = 1,nxyz
            i = j + nxyz*(ie-1)
            arg1 = EqAngAlph(i)
            arg2 = EqAngBeta(i)
            CS_A_11(i) = -SphR
     $         * cs_long(i) * sn_lati(i)    / cos(arg1)**2
            CS_A_12(i) = SphR
     $         * sn_long(i) * sn_lati(i)    / cos(arg2)**2
            CS_A_21(i) = SphR 
     $         * sn_long(i) * sn_lati(i)**2 / cos(arg1)**2
            CS_A_22(i) = SphR 
     $         * cs_long(i) * sn_lati(i)**2 / cos(arg2)**2
          enddo
        endif
      enddo

c     Compute inv(A) and Jacobian
      do i=1,npts   ! compute inv(A)
            CS_Atmp = CS_A_11(i)*CS_A_22(i)
     $              - CS_A_12(i)*CS_A_21(i)
         CS_ainv11(i) =  CS_A_22(i)/CS_Atmp
         CS_ainv12(i) = -CS_A_12(i)/CS_Atmp
         CS_ainv21(i) = -CS_A_21(i)/CS_Atmp
         CS_ainv22(i) =  CS_A_11(i)/CS_Atmp

         CS_Jac(i,1,1,1) = abs(CS_Atmp)
c         CS_Jac(i,1,1,1) = SphR**2 / cos(arg1)**2 / cos(arg2)**2
c     $      / ( 1.0 + tan(arg1)**2 + tan(arg2)**2 )**1.5
      enddo

C     Test and replace d(rst)/d(xyz)
      if(nid.eq.0) write(*,*)'Lan>> chk Jac start'
      do ie=1,nelt
        call CHKJAC(CS_Jac(1,1,1,ie),nxyz,ie,xm1,ym1,zm1,ndim,ierr)
      enddo

      if (nid.eq.0) write(*,*)'Lan>> Jac old: jacm,jacm1'
     $             ,jacm(1),jacm1(1,1,1,1)

      call col2(jacm1,CS_Jac,npts)
      call col2(jacm,CS_Jac,npts)
      call col2(bmn,CS_Jac,npts)
      call copy(bm1,bmn,npts)

      if (nid.eq.0) write(*,*)'Lan>> Jac new: jacm,jacm1'
     $             ,jacm(1),jacm1(1,1,1,1)


C     Test and replace d(rst)/d(xyz), ToDo: replace later by Lan
      nel = iglsum(nelt,1)
      dx1v = (pi/sqrt(nel/6.0))/2.0
      Jacdx = dx1v/2
      tmp_dsdx(1) = glmax(rxm1,npts)
      tmp_dsdx(2) = glmax(rym1,npts)
      tmp_dsdx(3) = glmax(sxm1,npts)
      tmp_dsdx(4) = glmax(sym1,npts)
      if(nid.eq.0) then
        write(*,*)'Lan>> Jacdx = dx1v/2 = ',Jacdx
        write(*,*)'Lan>> test dsdx 11/max',rxm1(1,1,1,1),tmp_dsdx(1)
        write(*,*)'Lan>> test dsdx 12/max',rym1(1,1,1,1),tmp_dsdx(2)
        write(*,*)'Lan>> test dsdx 21/max',sxm1(1,1,1,1),tmp_dsdx(3)
        write(*,*)'Lan>> test dsdx 22/max',sym1(1,1,1,1),tmp_dsdx(4)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine get_one_way_wind(vlong,vlati,vvx,vvy,vvz
     $                           ,vu1,vu2,alpha,u0)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'CUBESPHERE'

      real vlong(lpts1)! v on geo-coordinate
     $   , vlati(lpts1)
     $   , vu1(lpts1)  ! v on EqAng
     $   , vu2(lpts1)
     $   , vvx(lpts1)  ! v on XYZ
     $   , vvy(lpts1)
     $   , vvz(lpts1)

      real alpha       ! angle of v between N-S axis
     $   , u0          ! max speed


      real sn_alpha,cs_alpha
      real arg1,arg2

      integer i

c     wind field vectors
      cs_alpha = cos(alpha)
      sn_alpha = sin(alpha)
      do i = 1,npts
         arg1 = EqAngAlph(i)
         arg2 = EqAngBeta(i)

C        compute V_long V_lati
         vlong(i) = u0 
     $            *(cs_alpha * cs_lati(i)
     $            + sn_alpha * cs_long(i) * sn_lati(i) )
         vlati(i) = -u0 * sn_alpha * sn_long(i)

         vvx(i) = -vlong(i) * sn_long(i)
     $            -vlati(i) * sn_lati(i) * cs_long(i)
         vvy(i) =  vlong(i) * cs_long(i)
     $            -vlati(i) * sn_lati(i) * sn_long(i)
         vvz(i) =  vlati(i) * cs_lati(i)

         vu1(i) = CS_ainv11(i) * vlong(i)
     $          + CS_ainv12(i) * vlati(i)
         vu2(i) = CS_ainv21(i) * vlong(i)
     $          + CS_ainv22(i) * vlati(i)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine get_testcase_h(csh,R,delta)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'CUBESPHERE'

      real csh(lpts1)
      real R, delta
      integer i

      npts = nx1*ny1*nz1*nelt

      do i = 1,npts
         csh(i)  = exp( -2.0*R**2/delta**2
     $                *(1-cs_lati(i)*cs_long(i)) )
      enddo

      return
      end
c-----------------------------------------------------------------------
